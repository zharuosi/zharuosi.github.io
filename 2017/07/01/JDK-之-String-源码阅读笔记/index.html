<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>JDK 之 String 源码阅读笔记 | emacsist</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="java,jdk,string," />
  

  <meta name="description" content="本文基于 JDK 1.8 ，所有代码都有 Mac 环境下， JDK 1.8 中测试  String 类的修饰1public final class String implements java.io.Serializable, Comparable&amp;lt;String&amp;gt;, CharSequence 首先，它是一个 final 类，这表明：该类是不能被继承的。 Why is String c">
<meta name="keywords" content="java,jdk,string">
<meta property="og:type" content="article">
<meta property="og:title" content="JDK 之 String 源码阅读笔记">
<meta property="og:url" content="https://emacsist.github.io/2017/07/01/JDK-之-String-源码阅读笔记/index.html">
<meta property="og:site_name" content="emacsist">
<meta property="og:description" content="本文基于 JDK 1.8 ，所有代码都有 Mac 环境下， JDK 1.8 中测试  String 类的修饰1public final class String implements java.io.Serializable, Comparable&amp;lt;String&amp;gt;, CharSequence 首先，它是一个 final 类，这表明：该类是不能被继承的。 Why is String c">
<meta property="og:updated_time" content="2017-07-03T10:47:26.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JDK 之 String 源码阅读笔记">
<meta name="twitter:description" content="本文基于 JDK 1.8 ，所有代码都有 Mac 环境下， JDK 1.8 中测试  String 类的修饰1public final class String implements java.io.Serializable, Comparable&amp;lt;String&amp;gt;, CharSequence 首先，它是一个 final 类，这表明：该类是不能被继承的。 Why is String c">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbe6" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?b870e52c6cd914cb42627e4a706700b7";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  

  
</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header LEFT">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tags/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/books/"
            rel="noopener noreferrer"
            target="_self"
            >
            阅读
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#String-类的修饰"><span class="toc-text">String 类的修饰</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#String-类的属性"><span class="toc-text">String 类的属性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#transient-VS-serialPersistentFields"><span class="toc-text">transient VS serialPersistentFields</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#常用的方法"><span class="toc-text">常用的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#length"><span class="toc-text">length()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#equals"><span class="toc-text">equals()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#处理-String-的方法"><span class="toc-text">处理 String 的方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#String-不能被修改？"><span class="toc-text">String 不能被修改？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#让我们来改变-String-的值！"><span class="toc-text">让我们来改变 String 的值！</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#什么！两个-String-“不同”，竟然-时返回-true"><span class="toc-text">什么！两个 String “不同”，竟然 == 时返回 true ?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#从字节码级别看"><span class="toc-text">从字节码级别看</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#结论"><span class="toc-text">结论</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#String-intern"><span class="toc-text">String.intern()</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#intern-在-字符串拼接时的注意事项！"><span class="toc-text">intern() 在 字符串拼接时的注意事项！</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK-1-6-JDK-1-7-JDK-1-8-之间的区别"><span class="toc-text">JDK 1.6, JDK 1.7, JDK 1.8 之间的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常量池相关的JVM参数"><span class="toc-text">常量池相关的JVM参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#什么时候该用-String-intern-？"><span class="toc-text">什么时候该用 String.intern() ？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#String-s-new-String-new-String"><span class="toc-text">String s = new String() + new String()</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#String-s-“hello”-“world”"><span class="toc-text">String s = “hello” + “world”</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#switch-与-String"><span class="toc-text">switch 与 String</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol></li></ol>
  </div>



<div class="content content-post LEFT">
   <article id="post-JDK-之-String-源码阅读笔记" class="article article-type-post" itemprop="blogPost">
    <header class="article-header">
        <h1 class="post-title">
            JDK 之 String 源码阅读笔记
        </h1>

        <div class="article-meta">
            <span>
        <i class="icon-calendar"></i>
        <span>2017.07.01</span>
            </span>

            
                <span class="article-author">
          <i class="icon-user"></i>
          <span>emacsist</span>
                </span>
                

                    
    <span class="article-category">
    <i class="icon-list"></i>
    
      <a class="tag-item" href="/tags/#java">
        <span class="tag-name">java</span>
    <span class="tag-size">( 116 )</span>
    </a>
    
      <a class="tag-item" href="/tags/#jdk">
        <span class="tag-name">jdk</span>
    <span class="tag-size">( 1 )</span>
    </a>
    
      <a class="tag-item" href="/tags/#string">
        <span class="tag-name">string</span>
    <span class="tag-size">( 1 )</span>
    </a>
    

        </span>
        

                        

                                

                                        

        </div>
    </header>

    <div class="article-content">
        
                            <blockquote>
<p>本文基于 JDK 1.8 ，所有代码都有 Mac 环境下， JDK 1.8 中测试</p>
</blockquote>
<h1 id="String-类的修饰"><a href="#String-类的修饰" class="headerlink" title="String 类的修饰"></a>String 类的修饰</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence</div></pre></td></tr></table></figure>
<p>首先，它是一个 <em>final</em> 类，这表明：该类是不能被继承的。</p>
<p><a href="https://stackoverflow.com/questions/2068804/why-is-string-class-declared-final-in-java" target="_blank" rel="external">Why is String class declared final in Java?</a></p>
<p>实现了 <em>Serializable</em> 接口，表明它是可序列化的<br>实现了 <em>Comparable</em> 接口，表示它是可比较的<br>实现了 <em>CharSequence</em> 接口，看该接口的说明，表示：它是一个可读取的 char 值的序列。该接口提供了不同的 char 序列的统一的形式和只读访问</p>
<h1 id="String-类的属性"><a href="#String-类的属性" class="headerlink" title="String 类的属性"></a>String 类的属性</h1><ul>
<li>private final char value[]; 这个存储的是 string 的值，用字符数组来保存</li>
<li>private int hash; // Default to 0 这个表示该 string 的 哈希码</li>
<li>private static final long serialVersionUID = -6849794470754667710L; 这个表示该 string 的序列化版本</li>
<li>private static final ObjectStreamField[] serialPersistentFields = new ObjectStreamField[0]; 这个用来保存要进行序列化的字段。默认情况下，所有的非 transient 非 static 修饰的字段都会被序列化，但可以用这个来进行选择性序列化的字段。</li>
</ul>
<p>其中 <em>serialPersistentFields</em> 主要是被 <em>java.io.ObjectStreamClass.getDeclaredSerialFields</em> 方法处理:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">ObjectStreamField[] serialPersistentFields = null;</div><div class="line">       try &#123;</div><div class="line">           Field f = cl.getDeclaredField(<span class="string">"serialPersistentFields"</span>);</div><div class="line">           int mask = Modifier.PRIVATE | Modifier.STATIC | Modifier.FINAL;</div><div class="line">           <span class="keyword">if</span> ((f.getModifiers() &amp; mask) == mask) &#123;</div><div class="line">               f.setAccessible(<span class="literal">true</span>);</div><div class="line">               serialPersistentFields = (ObjectStreamField[]) f.get(null);</div><div class="line">           &#125;</div><div class="line">       &#125; catch (Exception ex) &#123;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (serialPersistentFields == null) &#123;</div><div class="line">           <span class="built_in">return</span> null;</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (serialPersistentFields.length == 0) &#123;</div><div class="line">           <span class="built_in">return</span> NO_FIELDS;</div><div class="line">       &#125;</div></pre></td></tr></table></figure>
<p>看它的注释可知：它返回给定的 class 显式声明的 <em>serialPersistentFields</em> 字段定义的可序列化的字段。如果没有适当地定义这个字段的话，就返回 null 。</p>
<h2 id="transient-VS-serialPersistentFields"><a href="#transient-VS-serialPersistentFields" class="headerlink" title="transient VS serialPersistentFields"></a>transient VS serialPersistentFields</h2><p><em>transient</em> ：用该关键字修改的字段，表示 <em>不序列化</em> 该字段<br><em>serialPersistentFields</em> : 表示只序列化这里指定的字段。注意，这里的优先级，高于 <em>transient</em> 。即，只要这里指定了序列化的，即使在该字段里用了 <em>transient</em> 来修饰，该字段也会进行序列化</p>
<p>测试代码:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div></pre></td><td class="code"><pre><div class="line">package org.agoncal.sample.jmh;</div><div class="line"></div><div class="line">import java.io.*;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by emacsist on 2017/6/30.</div><div class="line"> */</div><div class="line">public class Test &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        write();</div><div class="line">        <span class="built_in">read</span>();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static final void <span class="function"><span class="title">read</span></span>() &#123;</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            PersonA personA = new PersonA();</div><div class="line">            FileInputStream fileIn =</div><div class="line">                    new FileInputStream(<span class="string">"/tmp/personA.bin"</span>);</div><div class="line">            ObjectInputStream <span class="keyword">in</span> = new ObjectInputStream(fileIn);</div><div class="line">            personA = (PersonA) in.readObject();</div><div class="line">            in.close();</div><div class="line">            fileIn.close();</div><div class="line">            System.out.println(personA);</div><div class="line">        &#125; catch (IOException i) &#123;</div><div class="line">            i.printStackTrace();</div><div class="line">        &#125; catch (ClassNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            PersonB personB = new PersonB();</div><div class="line">            FileInputStream fileIn =</div><div class="line">                    new FileInputStream(<span class="string">"/tmp/personB.bin"</span>);</div><div class="line">            ObjectInputStream <span class="keyword">in</span> = new ObjectInputStream(fileIn);</div><div class="line">            personB = (PersonB) in.readObject();</div><div class="line">            in.close();</div><div class="line">            fileIn.close();</div><div class="line">            System.out.println(personB);</div><div class="line">        &#125; catch (IOException i) &#123;</div><div class="line">            i.printStackTrace();</div><div class="line">        &#125; catch (ClassNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static final void <span class="function"><span class="title">write</span></span>() &#123;</div><div class="line">        try &#123;</div><div class="line">            PersonA personA = new PersonA();</div><div class="line">            FileOutputStream fileOut =</div><div class="line">                    new FileOutputStream(<span class="string">"/tmp/personA.bin"</span>);</div><div class="line">            ObjectOutputStream out = new ObjectOutputStream(fileOut);</div><div class="line">            out.writeObject(personA);</div><div class="line">            out.close();</div><div class="line">            fileOut.close();</div><div class="line">        &#125; catch (IOException i) &#123;</div><div class="line">            i.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            PersonB personB = new PersonB();</div><div class="line">            FileOutputStream fileOut =</div><div class="line">                    new FileOutputStream(<span class="string">"/tmp/personB.bin"</span>);</div><div class="line">            ObjectOutputStream out = new ObjectOutputStream(fileOut);</div><div class="line">            out.writeObject(personB);</div><div class="line">            out.close();</div><div class="line">            fileOut.close();</div><div class="line">        &#125; catch (IOException i) &#123;</div><div class="line">            i.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    public static class PersonA implements Serializable &#123;</div><div class="line">        private String hello = <span class="string">"Hello World"</span>;</div><div class="line">        transient private Integer age = 18;</div><div class="line"></div><div class="line">        public String <span class="function"><span class="title">getHello</span></span>() &#123;</div><div class="line">            <span class="built_in">return</span> hello;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public void setHello(String hello) &#123;</div><div class="line">            this.hello = hello;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public Integer <span class="function"><span class="title">getAge</span></span>() &#123;</div><div class="line">            <span class="built_in">return</span> age;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public void setAge(Integer age) &#123;</div><div class="line">            this.age = age;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public String <span class="function"><span class="title">toString</span></span>() &#123;</div><div class="line">            <span class="built_in">return</span> <span class="string">"personA["</span> + hello + <span class="string">", "</span> + age + <span class="string">"]"</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static class PersonB implements Serializable &#123;</div><div class="line">        private String hello = <span class="string">"Hello World"</span>;</div><div class="line">        transient private Integer age = 18;</div><div class="line"></div><div class="line"></div><div class="line">        private static final ObjectStreamField[] serialPersistentFields =</div><div class="line">                new ObjectStreamField[1];</div><div class="line"></div><div class="line">        static &#123;</div><div class="line">            serialPersistentFields[0] = new ObjectStreamField(<span class="string">"age"</span>, Integer.class);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public String <span class="function"><span class="title">getHello</span></span>() &#123;</div><div class="line">            <span class="built_in">return</span> hello;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public void setHello(String hello) &#123;</div><div class="line">            this.hello = hello;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public Integer <span class="function"><span class="title">getAge</span></span>() &#123;</div><div class="line">            <span class="built_in">return</span> age;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public void setAge(Integer age) &#123;</div><div class="line">            this.age = age;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public String <span class="function"><span class="title">toString</span></span>() &#123;</div><div class="line">            <span class="built_in">return</span> <span class="string">"personB["</span> + hello + <span class="string">", "</span> + age + <span class="string">"]"</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">personA[Hello World, null]</div><div class="line">personB[null, 18]</div></pre></td></tr></table></figure>
<p>可以看到，PersonB 的 age 字段用了 transient 修饰，但它是在 serialPersistentFields 里，但它还是被序列化了。</p>
<h1 id="常用的方法"><a href="#常用的方法" class="headerlink" title="常用的方法"></a>常用的方法</h1><h2 id="length"><a href="#length" class="headerlink" title="length()"></a>length()</h2><p>它返回的是内部表示的 char 数组的长度</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">value.length</div></pre></td></tr></table></figure>
<h2 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h2><p>它判断是否是相同的对象，然后再判断是否是 String 的实例，如果是String实例，就从头到尾进行每一个字符的比较，直到有没的字符为止。</p>
<h2 id="处理-String-的方法"><a href="#处理-String-的方法" class="headerlink" title="处理 String 的方法"></a>处理 String 的方法</h2><p>通过看源码可知，所有处理 String 的方法，都是通过返回一个新的 String 对象的，而不是在原有的 String 对象上面进行字符 value 数组的修改。</p>
<p>看到网上一些源码分析的文章，说是因为 value 被定义为 final ，所以不能修改。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private final char value[];</div></pre></td></tr></table></figure>
<p>一个字段被定义为 final ，它的不能 <em>修改</em> 是指不能指向其他的对象了，而只能一直指向当前这个 value 的对象。<br>但 value 对象自身，还是可以修改的，比如下面的代码:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">        final char[] hello = <span class="string">"hello world"</span>.toCharArray();</div><div class="line">        System.out.println(hello);</div><div class="line">        hello[0] = <span class="string">'H'</span>;</div><div class="line">        System.out.println(hello);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出为</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hello world</div><div class="line">Hello world</div></pre></td></tr></table></figure>
<p>但如果这样子的话，就不能被编译通过了:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">char[] newHello = <span class="string">"new hello world"</span>.toCharArray();</div><div class="line">hello = newHello;</div></pre></td></tr></table></figure>
<h1 id="String-不能被修改？"><a href="#String-不能被修改？" class="headerlink" title="String 不能被修改？"></a>String 不能被修改？</h1><p>网上大多资料，一直在说什么 String 是不可变的。但这种说法，我不知道其实说这些话的人，是不是真的理解了其实的本质。反正，我个人理解起来，是挺费劲的。所以，今天才抽点空来详细看看 String 的源码。</p>
<p><em>final</em> 的类：表示不能被继承。仅此而已<br><em>final</em> 字段：如果是对象类型，则表示对象的引用不可变（但对象自身的状态还是可变的）；如果是基础类型，表示一旦初始化了，就不能再修改它的值了。<br><em>final</em> 方法：表示不能被子类覆盖。</p>
<p>通过源码我们知道 <em>value</em> 是 String 内部持有的真正的对象，String 是用它来保存它表示其值的，我们知道数组在Java中是对象的一种，也就是说 <em>final char value[]</em> 仅仅表示它不能指向其他的 <em>char[]</em> 对象引用了，而 <em>char valuel[]</em> 自身的内容，其实是可以改变的。那为什么大家都在说，String 是不可变的类型呢，因为 String 类中，根本没有提供 API 给你修改 <em>char valuel[]</em> 的内容.</p>
<p>String 中的所有的修改方法，都是复制一个新的 <em>char value[]</em> 的值然后作为 String 对象返回的。（为什么呢？这里涉及的比较多了，简单说一下，就是Java的团队认为，字符串复用的好处，大于坏处，所以就使用了字符串复用的方式：即通过 Constant Pool 来维护字符串常量池）</p>
<p>比如有两个字段:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String hello = <span class="string">"abc123"</span>;</div><div class="line">String hello2 = <span class="string">"abc123"</span>;</div></pre></td></tr></table></figure>
<p>在Java内部， hello 与 hello2 其实都是指向同一个字符串 “abc123” 的内存区域的。比如下面的代码，可以看到:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">    String hello = <span class="string">"abc123"</span>;</div><div class="line">    String hello2 = <span class="string">"abc123"</span>;</div><div class="line"></div><div class="line">    String helloNew = new String(<span class="string">"abc123"</span>);</div><div class="line">    String hello2New = new String(<span class="string">"abc123"</span>);</div><div class="line">    System.out.println(<span class="string">"hello 的地址 =&gt; "</span> + Integer.toHexString(System.identityHashCode(hello)));</div><div class="line">    System.out.println(<span class="string">"hello2 的地址 =&gt; "</span> + Integer.toHexString(System.identityHashCode(hello2)));</div><div class="line"></div><div class="line">    System.out.println(<span class="string">"helloNew 的地址 =&gt; "</span> + Integer.toHexString(System.identityHashCode(helloNew)));</div><div class="line">    System.out.println(<span class="string">"hello2New 的地址 =&gt; "</span> + Integer.toHexString(System.identityHashCode(hello2New)));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在我的 Mac 上输出如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">hello 的地址 =&gt; 6f94fa3e</div><div class="line">hello2 的地址 =&gt; 6f94fa3e</div><div class="line">helloNew 的地址 =&gt; 5e481248</div><div class="line">hello2New 的地址 =&gt; 66d3c617</div></pre></td></tr></table></figure>
<p>可以看到 <em>hello</em> 与 <em>hello2</em> 的地址是一样的，也就说明 <em>hello == hello2</em> ，<em>helloNew</em> 与 <em>hello2New</em> 的地址是不一样的，也就说明 <em>helloNew != hello2New</em> </p>
<h1 id="让我们来改变-String-的值！"><a href="#让我们来改变-String-的值！" class="headerlink" title="让我们来改变 String 的值！"></a>让我们来改变 String 的值！</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException &#123;</div><div class="line">        String hello = <span class="string">"abc"</span>;</div><div class="line">        System.out.println(Integer.toHexString(System.identityHashCode(hello)));</div><div class="line">        System.out.println(Integer.toHexString(System.identityHashCode(<span class="string">"abc"</span>)));</div><div class="line"></div><div class="line">        Field valueField = String.class.getDeclaredField(<span class="string">"value"</span>);</div><div class="line">        valueField.setAccessible(<span class="literal">true</span>);</div><div class="line">        valueField.set(hello, <span class="string">"newValue"</span>.toCharArray());</div><div class="line">        System.out.println(<span class="string">"现在 hello 的值为 =&gt;"</span> + hello);</div><div class="line">        System.out.println(Integer.toHexString(System.identityHashCode(hello)));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">6f94fa3e</div><div class="line">6f94fa3e</div><div class="line">现在 hello 的值为 =&gt;newValue</div><div class="line">6f94fa3e</div></pre></td></tr></table></figure>
<h1 id="什么！两个-String-“不同”，竟然-时返回-true"><a href="#什么！两个-String-“不同”，竟然-时返回-true" class="headerlink" title="什么！两个 String “不同”，竟然 == 时返回 true ?"></a>什么！两个 String “不同”，竟然 == 时返回 true ?</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">package org.agoncal.sample.jmh;</div><div class="line"></div><div class="line"></div><div class="line">import java.lang.reflect.Field;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by emacsist on 2017/6/30.</div><div class="line"> */</div><div class="line">public class Test &#123;</div><div class="line">    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException &#123;</div><div class="line">        String hello = <span class="string">"abc"</span>;</div><div class="line">        Field valueField = String.class.getDeclaredField(<span class="string">"value"</span>);</div><div class="line">        valueField.setAccessible(<span class="literal">true</span>);</div><div class="line">        valueField.set(hello, <span class="string">"newValue"</span>.toCharArray());</div><div class="line"></div><div class="line">        String hello2 = <span class="string">"abc"</span>;</div><div class="line">        System.out.println(<span class="string">"hello =&gt;"</span> + hello);</div><div class="line">        System.out.println(<span class="string">"hello == hello2 =&gt; "</span> + (hello == hello2));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hello =&gt;newValue</div><div class="line">hello == hello2 =&gt; <span class="literal">true</span></div></pre></td></tr></table></figure>
<p>虽然我们 <em>看到</em>  hello2 的值为 “abc”，但其实在JVM内部，并不是 “abc”，而是 “newValue” 了，所以输出为 <em>true</em><br>这是一个陷阱，因为我们通过反射，修改了 JVM 对字符串 “abc” 的内部表示了（即，对于JVM来说，”abc” 就表示是 “newValue” 了，你可以认为 “abc” 是 “newValue” 的别名！）比如:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out.println(<span class="string">"abc"</span>);</div></pre></td></tr></table></figure>
<p>JVM 就会输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">newValue</div></pre></td></tr></table></figure>
<p>所以，你永远输出不了 “abc” 这个常量字符串了！</p>
<p>注意，这里说的是常量字符串，通过下面的变换，也是可以输出的，但这样子就不是常量字符串”abc”了, 而是对象内容输出的拼接了～:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out.println(new String(<span class="string">"a"</span>) + new String(<span class="string">"bc"</span>));</div></pre></td></tr></table></figure>
<h1 id="从字节码级别看"><a href="#从字节码级别看" class="headerlink" title="从字节码级别看"></a>从字节码级别看</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">26: ldc           <span class="comment">#2                  // String abc</span></div><div class="line">28: astore_3</div><div class="line">29: getstatic     <span class="comment">#10                 // Field java/lang/System.out:Ljava/io/PrintStream;</span></div><div class="line">32: aload_3</div><div class="line">33: invokevirtual <span class="comment">#11                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></div></pre></td></tr></table></figure>
<p>为什么在字节码里，常量池表项的索引 #2，内容是 “abc”，但输出来的还是 “newValue” 呢？</p>
<p>可以推论：这是因为我们通过反射，修改了JVM的运行时对 “abc” 字符串常量的表示形式了。虽然字节码中反编译时，它显示的是 “abc”，这是静态的，而显示的时候，是运行时动态的内容了，所以才会出现这种情况。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>所以，为什么一般说 String 不可变？其实只是 API 本身并没有提供让你修改 value 字符数组的接口，而且 String 类，是 final 的，也就是说，它也不允许你通过继承来修改它。</p>
<p>因为 JVM 使用了常量池这个东东（注意，常量池并不仅仅只有字符串常量，Class 文件中的方法符号，字段符号等这些，也是常量池的一部分！） ，所以才要求 String 是不可变的，它们是互为表里关系，一脉相乘的。</p>
<p>通过上面的例子，你就可以知道，如果JVM内部是使用常量池复用的规则，但又允许你修改的话，就会出现上面的问题了。”abc” 输出的不是 “abc” ～ 你不是你，我也不是我了，然后就会有另一个问题了： </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Who are you ?</div></pre></td></tr></table></figure>
<p>注意：在 Java 里，任何通过 new 出来的对象，都是唯一的！（即物理地址上是唯一的， 即用 <em>==</em> 来比较的，只要 <em>System.identityHashCode()</em> 输出来的值是相等的，那么 <em>==</em> 一定会返回 true）</p>
<p>正因为如此，所以，Java 里有个 <em>equals</em> 的方法，允许我们判断两个对象的 <em>逻辑相等</em> ，比如我们定义：只要属性中年龄相同的两个对象就是 <em>相等</em> 的，那么我们就可以通过实现自定义的 <em>equals</em> 方法，来进行逻辑上的相等。</p>
<h1 id="String-intern"><a href="#String-intern" class="headerlink" title="String.intern()"></a>String.intern()</h1><blockquote>
<p>注意，该方法是属于本地方法。它的声明如下: </p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public native String intern();</div></pre></td></tr></table></figure>
<p>它的作用是：如果从常量池中，没有与该 String equals（即内容相同）的 String 的话，则将该 String 放进常量池中，然后返回该 String 在常量池中的引用；如果常量池已经存在该 String 的话，则直接返回常量池中的引用。</p>
<p>即：该方法保证返回的是从常量池中返回的唯一的引用。</p>
<p>对于普通的 Java 字符串字面量，Java会自动进行 intern() 操作。</p>
<p>例如:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">package org.agoncal.sample.jmh;</div><div class="line"></div><div class="line">public class Test &#123;</div><div class="line">    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, InterruptedException &#123;</div><div class="line">        String hello = <span class="string">"hello"</span>;</div><div class="line">        String hello2 = new String(<span class="string">"hello"</span>);</div><div class="line">        System.out.println(hello == hello2);</div><div class="line">        System.out.println(hello.intern() == hello2.intern());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它会输出:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="literal">false</span></div><div class="line"><span class="literal">true</span></div></pre></td></tr></table></figure>
<h2 id="intern-在-字符串拼接时的注意事项！"><a href="#intern-在-字符串拼接时的注意事项！" class="headerlink" title="intern() 在 字符串拼接时的注意事项！"></a>intern() 在 字符串拼接时的注意事项！</h2><blockquote>
<p>注意，是在拼接时才有，非拼接的情况，与假设常量池中已经有该字符串的情况下样，即它返回的是常量池中的地址，但它不会与堆中的地址相同。</p>
</blockquote>
<p>在JDK 1.8 中（其他JDK没实验过），经验证，当执行字符串拼接时（即使两个拼接的是变量，而不是字符串字面量），拼接后的字符串的情况：</p>
<p>如果常量池中，还没有该字符串的话，则会把它从堆内存的地址， <em>提升为常量池中的地址</em><br>如果常量池中，已经有该字符串的话，则 intern() 方法只是返回常量池中的地址，但该对象原地址不变</p>
<p>证明代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">package org.agoncal.sample.jmh;</div><div class="line"></div><div class="line">public class Test &#123;</div><div class="line">    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, InterruptedException &#123;</div><div class="line">        System.out.println(<span class="string">"第一次常量池中没有相同的字符串的情况"</span>);</div><div class="line">        String name = new String(<span class="string">"emac"</span>) + new String(<span class="string">"sist"</span>);</div><div class="line">        System.out.println(<span class="string">"name 变量的地址:"</span> + Integer.toHexString(System.identityHashCode(name)));</div><div class="line">        System.out.println(<span class="string">"name 代表的常量池的地址:"</span> + Integer.toHexString(System.identityHashCode(name.intern())));</div><div class="line">        System.out.println(<span class="string">"emacsist 常量的地址:"</span> + Integer.toHexString(System.identityHashCode(<span class="string">"emacsist"</span>)));</div><div class="line"></div><div class="line">        System.out.println();</div><div class="line">        System.out.println(<span class="string">"第一次常量池中已经有相同的字符串的情况"</span>);</div><div class="line">        String name2Interned = <span class="string">"emacsist2"</span>;//Java会自动将它放入常量池，模拟常量池已经有的情况</div><div class="line">        String name2 = new String(<span class="string">"emacsist2"</span>);</div><div class="line">        System.out.println(<span class="string">"name 变量的地址:"</span> + Integer.toHexString(System.identityHashCode(name2)));</div><div class="line">        System.out.println(<span class="string">"name 代表的常量池的地址:"</span> + Integer.toHexString(System.identityHashCode(name2.intern())));</div><div class="line">        System.out.println(<span class="string">"emacsist2 常量的地址:"</span> + Integer.toHexString(System.identityHashCode(<span class="string">"emacsist2"</span>)));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">第一次常量池中没有相同的字符串的情况</div><div class="line">name 变量的地址:6f94fa3e</div><div class="line">name 代表的常量池的地址:6f94fa3e</div><div class="line">emacsist 常量的地址:6f94fa3e</div><div class="line"></div><div class="line">第一次常量池中已经有相同的字符串的情况</div><div class="line">name 变量的地址:5e481248</div><div class="line">name 代表的常量池的地址:66d3c617</div><div class="line">emacsist2 常量的地址:66d3c617</div></pre></td></tr></table></figure>
<h2 id="JDK-1-6-JDK-1-7-JDK-1-8-之间的区别"><a href="#JDK-1-6-JDK-1-7-JDK-1-8-之间的区别" class="headerlink" title="JDK 1.6, JDK 1.7, JDK 1.8 之间的区别"></a>JDK 1.6, JDK 1.7, JDK 1.8 之间的区别</h2><p><em>&lt;=JDK 1.6</em> : intern() 的字符串，它会放在 Java 堆中的  Permanent Generation 内存区域<br><em>&gt;= JDK 1.7</em> : intern() 的字符串，它分配在普通的 Java 堆中，即 Young 和 Old Generation 内存区域( <a href="http://www.oracle.com/technetwork/java/javase/jdk7-relnotes-418459.html#jdk7changes" target="_blank" rel="external">Oracle JDK 7 changes</a> ) (这意味着可以被GC)</p>
<h2 id="常量池相关的JVM参数"><a href="#常量池相关的JVM参数" class="headerlink" title="常量池相关的JVM参数"></a>常量池相关的JVM参数</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[12:23:10] emacsist:~ $ java -XX:+PrintFlagsFinal -version | grep StringTable</div><div class="line">     bool PrintStringTableStatistics                = <span class="literal">false</span>                               &#123;product&#125;</div><div class="line">    uintx StringTableSize                           = 60013                               &#123;product&#125;</div><div class="line">Java(TM) SE Runtime Environment (build 1.8.0_74-b02)</div><div class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.74-b02, mixed mode)</div></pre></td></tr></table></figure>
<ul>
<li>-XX:+PrintStringTableStatistics : 在JVM退出时，打印当前JVM的常量池统计信息</li>
<li>-XX:StringTableSize=N : 设置 StringTable 的大小</li>
</ul>
<p>字符中常量池的大小范围:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">StringTable size of 1000 is invalid; must be between 1009 and 2305843009213693951</div></pre></td></tr></table></figure>
<p>输出例子:(-XX:+PrintStringTableStatistics  -XX:StringTableSize=1009)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">SymbolTable statistics:</div><div class="line">Number of buckets       :     20011 =    160088 bytes, avg   8.000</div><div class="line">Number of entries       :     12127 =    291048 bytes, avg  24.000</div><div class="line">Number of literals      :     12127 =    468448 bytes, avg  38.629</div><div class="line">Total footprint         :           =    919584 bytes</div><div class="line">Average bucket size     :     0.606</div><div class="line">Variance of bucket size :     0.607</div><div class="line">Std. dev. of bucket size:     0.779</div><div class="line">Maximum bucket size     :         6</div><div class="line">StringTable statistics:</div><div class="line">Number of buckets       :      1009 =      8072 bytes, avg   8.000</div><div class="line">Number of entries       :       865 =     20760 bytes, avg  24.000</div><div class="line">Number of literals      :       865 =     58048 bytes, avg  67.108</div><div class="line">Total footprint         :           =     86880 bytes</div><div class="line">Average bucket size     :     0.857</div><div class="line">Variance of bucket size :     0.814</div><div class="line">Std. dev. of bucket size:     0.902</div><div class="line">Maximum bucket size     :         5</div></pre></td></tr></table></figure>
<p>参考资料：</p>
<ul>
<li><a href="http://java-performance.info/string-intern-in-java-6-7-8/" target="_blank" rel="external">java-performance.info</a></li>
<li><a href="http://tech.meituan.com/in_depth_understanding_string_intern.html" target="_blank" rel="external">美团-深入解析String#intern</a></li>
</ul>
<h2 id="什么时候该用-String-intern-？"><a href="#什么时候该用-String-intern-？" class="headerlink" title="什么时候该用 String.intern() ？"></a>什么时候该用 String.intern() ？</h2><p>一般情况下，我们使用字符串的比较，一般是使用 <em>String.equals()</em> ，极少见到 <em>String.intern() == String.intern()</em> 。<br>透过源码可知，equals 是逐个逐个字符从头开始进行比较的，但是 inter() 它是直接比较两个引用的。</p>
<p>所以，通常来说，直接比较引用会比一个一个字符地来比较的性能更高。（即 == 比 equals() 这种方法调用来得更快）</p>
<p>注意，如果决定使用 intern() 来进行字符串的比较，请记得将所有字符串都要进行 intern() 之后再进行比较～</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">package org.agoncal.sample.jmh;</div><div class="line"></div><div class="line">public class Test &#123;</div><div class="line">    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, InterruptedException &#123;</div><div class="line">        String hello = <span class="string">"hello world hello worldhello worldhello worldhello worldhello worldhello worldhello worldhello worldhello worldhello world"</span>;</div><div class="line">        String hello2 = new String(<span class="string">"hello world hello worldhello worldhello worldhello worldhello worldhello worldhello worldhello worldhello worldhello world"</span>);</div><div class="line">        final int N = 100000;</div><div class="line">        long start = System.currentTimeMillis();</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (int i = 0; i &lt; N; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (!hello.equals(hello2)) &#123;</div><div class="line">                System.out.println(<span class="string">"not equals"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"equals cost "</span> + (System.currentTimeMillis() - start) + <span class="string">" ms"</span>);</div><div class="line"></div><div class="line">        start = System.currentTimeMillis();</div><div class="line">        String hello2Intern = hello2.intern();</div><div class="line">        <span class="keyword">for</span> (int i = 0; i &lt; N; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (hello != hello2Intern) &#123;</div><div class="line">                System.out.println(<span class="string">"not equals"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"== cost "</span> + (System.currentTimeMillis() - start) + <span class="string">" ms"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">equals cost 62 ms</div><div class="line">== cost 1 ms</div></pre></td></tr></table></figure>
<p>注意，不要在循环中一直调用 <em>intern()</em> ，因为它是本地方法的调用，在循环里调用的话，这样子会比在循环里调用普通的 Java 的方法更耗时。（调用本地方法比较昂贵）</p>
<p>参考资料：</p>
<ul>
<li><a href="https://stackoverflow.com/questions/1091045/is-it-good-practice-to-use-java-lang-string-intern" target="_blank" rel="external">stackoverflow Is it good practice to use java.lang.String.intern()?</a></li>
</ul>
<h1 id="String-s-new-String-new-String"><a href="#String-s-new-String-new-String" class="headerlink" title="String s = new String() + new String()"></a>String s = new String() + new String()</h1><p>或者</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String hello = <span class="string">"hello"</span>;</div><div class="line">String world = <span class="string">"world"</span>;</div><div class="line">String s = hello + world;</div></pre></td></tr></table></figure>
<p>因为Java编译器的原因，这种代码，在编译的时候，会被编译为:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String s = new StringBuilder().append(new String()).append(new String()).toString();</div></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String s = new StringBuilder().append(hello).append(world).toString();</div></pre></td></tr></table></figure>
<p>所以：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String hello = new String(<span class="string">"hello"</span>) + new String(<span class="string">"world"</span>);</div></pre></td></tr></table></figure>
<p>会被编译为:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String hello = new StringBuilder().append(new String(<span class="string">"hello"</span>)).append(new String(<span class="string">"world"</span>)).toString();</div></pre></td></tr></table></figure>
<p>被编译后的字节码如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">stack=4, locals=2, args_size=1</div><div class="line">    0: new           <span class="comment">#2                  // class java/lang/StringBuilder</span></div><div class="line">    3: dup</div><div class="line">    4: invokespecial <span class="comment">#3                  // Method java/lang/StringBuilder."&lt;init&gt;":()V</span></div><div class="line">    7: new           <span class="comment">#4                  // class java/lang/String</span></div><div class="line">   10: dup</div><div class="line">   11: ldc           <span class="comment">#5                  // String hello</span></div><div class="line">   13: invokespecial <span class="comment">#6                  // Method java/lang/String."&lt;init&gt;":(Ljava/lang/String;)V</span></div><div class="line">   16: invokevirtual <span class="comment">#7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></div><div class="line">   19: new           <span class="comment">#4                  // class java/lang/String</span></div><div class="line">   22: dup</div><div class="line">   23: ldc           <span class="comment">#8                  // String world</span></div><div class="line">   25: invokespecial <span class="comment">#6                  // Method java/lang/String."&lt;init&gt;":(Ljava/lang/String;)V</span></div><div class="line">   28: invokevirtual <span class="comment">#7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></div><div class="line">   31: invokevirtual <span class="comment">#9                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span></div><div class="line">   34: astore_1</div><div class="line">   35: <span class="built_in">return</span></div></pre></td></tr></table></figure>
<h1 id="String-s-“hello”-“world”"><a href="#String-s-“hello”-“world”" class="headerlink" title="String s = “hello” + “world”"></a>String s = “hello” + “world”</h1><p>它会直接被编译器进行优化为: String s = “helloworld” 并且会将它(“helloworld”)放入常量池中（注意不是 “hello” 和  “world” 分别放入常量池，而是 “helloworld” 一个）</p>
<p>编译后的字节码:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Code:</div><div class="line">    stack=1, locals=2, args_size=1</div><div class="line">       0: ldc           <span class="comment">#2                  // String helloworld</span></div><div class="line">       2: astore_1</div><div class="line">       3: <span class="built_in">return</span></div></pre></td></tr></table></figure>
<h1 id="switch-与-String"><a href="#switch-与-String" class="headerlink" title="switch 与 String"></a>switch 与 String</h1><p>从JDK 1.7开始，switch 可以用 String 了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public static final void s(String hello) &#123;</div><div class="line">    switch (hello) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="string">"world"</span>:</div><div class="line">            System.out.println(<span class="string">"world"</span>);</div><div class="line">        <span class="keyword">case</span> <span class="string">"hello"</span>:</div><div class="line">            System.out.println(<span class="string">"hello"</span>);</div><div class="line">            <span class="built_in">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="string">"hello2"</span>:</div><div class="line">            System.out.println(<span class="string">"hello2"</span>);</div><div class="line">            <span class="built_in">break</span>;</div><div class="line">        default:</div><div class="line">            System.out.println(<span class="string">"default"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，它的字节码如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">0: aload_0</div><div class="line">1: astore_1</div><div class="line">2: iconst_m1</div><div class="line">3: istore_2</div><div class="line">4: aload_1</div><div class="line">5: invokevirtual <span class="comment">#8                  // Method java/lang/String.hashCode:()I</span></div><div class="line">8: lookupswitch  &#123; // 3</div><div class="line">    -1220935264: 72</div><div class="line">       99162322: 58</div><div class="line">      113318802: 44</div><div class="line">        default: 83</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>伪代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">String tmp = hello; //aload_0 表示将第0个参数，即 hello 压入栈，astore_1 表示将栈顶的元素弹出，保存到第一个局部变量中，这里假设为 tmp</div><div class="line">int tmp_i = -1; // iconst_m1 表示将 -1 压入栈，所以这里的伪代码是这样子，tmp_i 就表示是 第1个局部变量</div><div class="line"></div><div class="line">// 即第0个局部变量为 String hello(xx_0的局部变量指令就是它)， 第1个局部变量为 String tmp = hello（xx_1的局部变量就是它），第2个局部变量为 int tmp_i = -1;（xx_2的局部变量指令就是它）</div><div class="line"></div><div class="line">然后根据 tmp.hashCode() 的结果，查找 lookupswitch 表，左边的是 hashCode 的值，右边为要跳转到的代码位置。那么它们是如何比较的？（这里仅以一个为例，假设与 <span class="string">"world"</span> 这个分支比较的情况：</div><div class="line"></div><div class="line">        44: aload_1</div><div class="line">        45: ldc           <span class="comment">#9                  // String world</span></div><div class="line">        47: invokevirtual <span class="comment">#10                 // Method java/lang/String.equals:(Ljava/lang/Object;)Z</span></div><div class="line">        50: ifeq          83</div><div class="line">        53: iconst_0</div><div class="line">        54: istore_2</div><div class="line">        55: goto          83</div><div class="line">        </div><div class="line">这段代码的伪代码如下:(在Java字节码中，0 表示 <span class="literal">false</span>, 1 表示 <span class="literal">true</span>)</div><div class="line"></div><div class="line"><span class="keyword">if</span> (!tmp.equals(<span class="string">"world"</span>))&#123;</div><div class="line">    goto 83行;</div><div class="line">&#125;</div><div class="line">tmp_i = 0</div><div class="line">goto 83 行;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">        83: iload_2</div><div class="line">        84: tableswitch   &#123; // 0 to 2</div><div class="line">                       0: 112</div><div class="line">                       1: 120</div><div class="line">                       2: 131</div><div class="line">                 default: 142</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">如果 !tmp.equals(<span class="string">"world"</span>)，则 tmp_i = -1, 否则 tmp_i = 0，在这里时，就已经是普通的 swith int 类型的代码了（因为 iload_2 就表示的是 tmp_id 这个 int 的值）</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在 swith 中使用 String 时，它步骤如下:</p>
<ol>
<li>调用 swith 变量中的String 的 <em>hashCode</em> 的方法，返回一个 int 值，保存到一个编译器生成的临时变量中，假设为 tmp_i</li>
<li>根据 <em>hashCode</em> 的结果，跳转到相应的，<em>由Java编译器生成的代码</em> ，它的伪代码就是字符串之间的 <em>equals</em> 的方法。（因为单纯地靠 HashCode 并不能决定两个字符串是否真的相同）</li>
<li>然后根据 <em>equals</em> 的结果，再设置相应的 tmp_i 的值（每个结果，从上到下依次是从 0 开始递增）</li>
<li>最后，切换为普通的 int 的 swith 代码了～（即直接比较 tmp_i 与 swith 表中各个项的 int 的值是否相等，然后再跳转到相应的代码）</li>
</ol>

                                
    </div>
</article>

   
  <div class="text-center donation">
    <div class="inner-donation">
      <span class="btn-donation">支持一下</span>
      <div class="donation-body">
        <div class="tip text-center">扫一扫，支持 emacsist</div>
        <ul class="theme.donation.items.length">
        
          <li class="item">
            <img src="/img/wxpay.jpeg" alt="">
          </li>
        
          <li class="item">
            <img src="/img/alipay.jpeg" alt="">
          </li>
        
        </ul>
      </div>
    </div>
  </div>


   



</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tags/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/books/"
              rel="noopener noreferrer"
              target="_self"
              >
              阅读
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    




    

    
	
  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
