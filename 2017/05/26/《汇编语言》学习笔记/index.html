<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>《汇编语言》学习笔记 | emacsist</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="汇编语言," />
  

  <meta name="description" content="第一章：基础知识汇编语言的组成 汇编指令：机器码助记符，有对应的机器码 伪指令：没有对应的机器码，由编译器执行，计算机并不执行 其他符号：如 +, -, *, / 等，由编译器识别，没有对应的机器码  指令和数据指令和数据，是应用上的概念。在内存或磁盘上，指令和数据没有任何区别，都是二进制信息。CPU在工作的时候，把有的信息看作指令，有的信息看作数据，为同样的信息赋予了不同的意义。 存储单元每个存">
<meta name="keywords" content="汇编语言">
<meta property="og:type" content="article">
<meta property="og:title" content="《汇编语言》学习笔记">
<meta property="og:url" content="https://emacsist.github.io/2017/05/26/《汇编语言》学习笔记/index.html">
<meta property="og:site_name" content="emacsist">
<meta property="og:description" content="第一章：基础知识汇编语言的组成 汇编指令：机器码助记符，有对应的机器码 伪指令：没有对应的机器码，由编译器执行，计算机并不执行 其他符号：如 +, -, *, / 等，由编译器识别，没有对应的机器码  指令和数据指令和数据，是应用上的概念。在内存或磁盘上，指令和数据没有任何区别，都是二进制信息。CPU在工作的时候，把有的信息看作指令，有的信息看作数据，为同样的信息赋予了不同的意义。 存储单元每个存">
<meta property="og:image" content="https://emacsist.github.io/img/assembly-00.png">
<meta property="og:image" content="https://emacsist.github.io/img/asm-get-week.jpg">
<meta property="og:updated_time" content="2017-06-08T09:05:04.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="《汇编语言》学习笔记">
<meta name="twitter:description" content="第一章：基础知识汇编语言的组成 汇编指令：机器码助记符，有对应的机器码 伪指令：没有对应的机器码，由编译器执行，计算机并不执行 其他符号：如 +, -, *, / 等，由编译器识别，没有对应的机器码  指令和数据指令和数据，是应用上的概念。在内存或磁盘上，指令和数据没有任何区别，都是二进制信息。CPU在工作的时候，把有的信息看作指令，有的信息看作数据，为同样的信息赋予了不同的意义。 存储单元每个存">
<meta name="twitter:image" content="https://emacsist.github.io/img/assembly-00.png">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbe6" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?b870e52c6cd914cb42627e4a706700b7";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  

  
</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header LEFT">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tags/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/books/"
            rel="noopener noreferrer"
            target="_self"
            >
            阅读
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#第一章：基础知识"><span class="toc-text">第一章：基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#汇编语言的组成"><span class="toc-text">汇编语言的组成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#指令和数据"><span class="toc-text">指令和数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#存储单元"><span class="toc-text">存储单元</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU-对存储器的读写"><span class="toc-text">CPU 对存储器的读写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据的读写"><span class="toc-text">数据的读写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#命令计算机读写"><span class="toc-text">命令计算机读写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#地址总线"><span class="toc-text">地址总线</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据总线"><span class="toc-text">数据总线</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#控制总线"><span class="toc-text">控制总线</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存地址空间"><span class="toc-text">内存地址空间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#大小"><span class="toc-text">大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存地址空间分配"><span class="toc-text">内存地址空间分配</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第二章：寄存器"><span class="toc-text">第二章：寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8086-CPU寄存器"><span class="toc-text">8086 CPU寄存器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字在寄存器中的存储"><span class="toc-text">字在寄存器中的存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#物理地址"><span class="toc-text">物理地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16位的CPU"><span class="toc-text">16位的CPU</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8086-CPU给出物理地址的方法"><span class="toc-text">8086 CPU给出物理地址的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#段地址-16-偏移地址-物理地址-的本质含义"><span class="toc-text">段地址 * 16 + 偏移地址 = 物理地址 的本质含义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#段寄存器"><span class="toc-text">段寄存器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#修改CS，IP的指令"><span class="toc-text">修改CS，IP的指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Windows下的-Debug-工具"><span class="toc-text">Windows下的 Debug 工具</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第三章：寄存器（内存访问）"><span class="toc-text">第三章：寄存器（内存访问）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#内存中字的存储"><span class="toc-text">内存中字的存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DS和-address"><span class="toc-text">DS和[address]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存的读写"><span class="toc-text">内存的读写</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#读"><span class="toc-text">读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#写"><span class="toc-text">写</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据段"><span class="toc-text">数据段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#栈"><span class="toc-text">栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU提供的栈机制"><span class="toc-text">CPU提供的栈机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#栈顶"><span class="toc-text">栈顶</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PUSH"><span class="toc-text">PUSH</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#空栈"><span class="toc-text">空栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#POP"><span class="toc-text">POP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#栈顶超界的问题"><span class="toc-text">栈顶超界的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#POP-和-PUSH-指令"><span class="toc-text">POP 和 PUSH 指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#栈段"><span class="toc-text">栈段</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第四章：第一个程序"><span class="toc-text">第四章：第一个程序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#编译"><span class="toc-text">编译</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#链接"><span class="toc-text">链接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#调试"><span class="toc-text">调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#整个过程"><span class="toc-text">整个过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DOS-的加载过程"><span class="toc-text">DOS 的加载过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#单任务执行过程"><span class="toc-text">单任务执行过程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第五章：-BX-和-loop指令"><span class="toc-text">第五章：[BX] 和 loop指令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#loop-指令"><span class="toc-text">loop 指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#debug-中的-G-命令"><span class="toc-text">debug 中的 G 命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#debug-中的-P-命令"><span class="toc-text">debug 中的 P 命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#debug-和汇编器-masm-对指令的不同处理"><span class="toc-text">debug 和汇编器 masm 对指令的不同处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一段安全的空间"><span class="toc-text">一段安全的空间</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第六章：包含多个段的程序"><span class="toc-text">第六章：包含多个段的程序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#程序第一条指令"><span class="toc-text">程序第一条指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#只用一个段来写代码"><span class="toc-text">只用一个段来写代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多段"><span class="toc-text">多段</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第七章：更灵活的定位内存地址的方法"><span class="toc-text">第七章：更灵活的定位内存地址的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#and-和-or-指令"><span class="toc-text">and 和 or 指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bx-idata"><span class="toc-text">[bx+idata]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SI-和-DI"><span class="toc-text">SI 和 DI</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bx-si-和-bx-di"><span class="toc-text">[bx+si] 和 [bx+di]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bx-si-idata-和-bx-di-idata"><span class="toc-text">[bx+si+idata] 和 [bx+di+idata]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#寻址方式"><span class="toc-text">寻址方式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第八章：数据处理的两个基本问题"><span class="toc-text">第八章：数据处理的两个基本问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#bx-si-di-和-bp"><span class="toc-text">bx, si, di 和 bp</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#机器指令处理的数据在什么地方"><span class="toc-text">机器指令处理的数据在什么地方</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据位置的表达"><span class="toc-text">数据位置的表达</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#立即数"><span class="toc-text">立即数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#寄存器"><span class="toc-text">寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#段地址（SA）和偏移地址（EA）"><span class="toc-text">段地址（SA）和偏移地址（EA）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#寻址方式-1"><span class="toc-text">寻址方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#直接寻址"><span class="toc-text">直接寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#寄存器间接寻址"><span class="toc-text">寄存器间接寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#寄存器相对寻址"><span class="toc-text">寄存器相对寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基址变址寻址"><span class="toc-text">基址变址寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#相对基址变址寻址"><span class="toc-text">相对基址变址寻址</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#要处理数据的长度"><span class="toc-text">要处理数据的长度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#div-指令"><span class="toc-text">div 指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dup"><span class="toc-text">dup</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第九章：转移指令的原理"><span class="toc-text">第九章：转移指令的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#转移指令分类"><span class="toc-text">转移指令分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#offset"><span class="toc-text">offset</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jmp-指令"><span class="toc-text">jmp 指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#依据位移进行转移的-jmp-指令"><span class="toc-text">依据位移进行转移的 jmp 指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#转移的目的地址在指令中的-jmp-指令"><span class="toc-text">转移的目的地址在指令中的 jmp 指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#转移地址在寄存器中的-jmp-指令"><span class="toc-text">转移地址在寄存器中的 jmp 指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#转移地址在内存中的-jmp-指令"><span class="toc-text">转移地址在内存中的 jmp 指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jcxz-指令"><span class="toc-text">jcxz 指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#loop-指令-1"><span class="toc-text">loop 指令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第十章：CALL-和-RET-指令"><span class="toc-text">第十章：CALL 和 RET 指令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ret-和-retf"><span class="toc-text">ret 和 retf</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#call-指令"><span class="toc-text">call 指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#依据位移进行转移的-call-指令"><span class="toc-text">依据位移进行转移的 call 指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#转移的目的地址在指令中的-call-指令"><span class="toc-text">转移的目的地址在指令中的 call 指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#转移地址在寄存器中的-call-指令"><span class="toc-text">转移地址在寄存器中的 call 指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#转移地址在内存中的-call-指令"><span class="toc-text">转移地址在内存中的 call 指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mul-指令"><span class="toc-text">mul 指令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第十一章：标志寄存器"><span class="toc-text">第十一章：标志寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0：CF"><span class="toc-text">0：CF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2：PF"><span class="toc-text">2：PF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4：AF"><span class="toc-text">4：AF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6：ZF"><span class="toc-text">6：ZF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7：SF"><span class="toc-text">7：SF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8：TF"><span class="toc-text">8：TF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9：IF"><span class="toc-text">9：IF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10：DF"><span class="toc-text">10：DF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11：OF"><span class="toc-text">11：OF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#adc-指令"><span class="toc-text">adc 指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sbb-指令"><span class="toc-text">sbb 指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cmp-指令"><span class="toc-text">cmp 指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#检测比较结果的条件转移指令"><span class="toc-text">检测比较结果的条件转移指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#je"><span class="toc-text">je</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jne"><span class="toc-text">jne</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jb"><span class="toc-text">jb</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jnb"><span class="toc-text">jnb</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ja"><span class="toc-text">ja</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jna"><span class="toc-text">jna</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pushf-和-popf"><span class="toc-text">pushf 和 popf</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第十二章：内中断"><span class="toc-text">第十二章：内中断</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#中断的产生"><span class="toc-text">中断的产生</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#中断向量表"><span class="toc-text">中断向量表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#中断过程"><span class="toc-text">中断过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#中断处理程序和-iret-指令"><span class="toc-text">中断处理程序和 iret 指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#响应中断的特殊情况"><span class="toc-text">响应中断的特殊情况</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第十三章：int-指令"><span class="toc-text">第十三章：int 指令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#BIOS-和-DOS-中断例程的安装过程"><span class="toc-text">BIOS 和 DOS 中断例程的安装过程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第十四章：端口"><span class="toc-text">第十四章：端口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#端口的读写"><span class="toc-text">端口的读写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SHL-和-SHR-指令"><span class="toc-text">SHL 和 SHR 指令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第十五章：外中断"><span class="toc-text">第十五章：外中断</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#外中断源"><span class="toc-text">外中断源</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#可屏蔽中断"><span class="toc-text">可屏蔽中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不可屏蔽中断"><span class="toc-text">不可屏蔽中断</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PC-机键盘的处理过程"><span class="toc-text">PC 机键盘的处理过程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#杂项"><span class="toc-text">杂项</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#显存的物理地址"><span class="toc-text">显存的物理地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ASCII-与-显卡文本模式显示"><span class="toc-text">ASCII 与 显卡文本模式显示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MOV"><span class="toc-text">MOV</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#汇编地址"><span class="toc-text">汇编地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jmp-near-xxx"><span class="toc-text">jmp near xxx</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#movsb-或-movsw"><span class="toc-text">movsb 或 movsw</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#偏移地址"><span class="toc-text">偏移地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cbw-或-cwd"><span class="toc-text">cbw 或 cwd</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#call-指令-1"><span class="toc-text">call 指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#相对近调用"><span class="toc-text">相对近调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#绝对近调用"><span class="toc-text">绝对近调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#绝对远调用"><span class="toc-text">绝对远调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#间接绝对远调用"><span class="toc-text">间接绝对远调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ret-和-retf-1"><span class="toc-text">ret 和 retf</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jmp"><span class="toc-text">jmp</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#相对短转移"><span class="toc-text">相对短转移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16位相对近转移"><span class="toc-text">16位相对近转移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16位间接绝对近转移"><span class="toc-text">16位间接绝对近转移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16位直接绝对远转移"><span class="toc-text">16位直接绝对远转移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16位间接绝对远转移"><span class="toc-text">16位间接绝对远转移</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#iret"><span class="toc-text">iret</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CMOS-RAM"><span class="toc-text">CMOS RAM</span></a></li></ol></li></ol>
  </div>



<div class="content content-post LEFT">
   <article id="post-《汇编语言》学习笔记" class="article article-type-post" itemprop="blogPost">
    <header class="article-header">
        <h1 class="post-title">
            《汇编语言》学习笔记
        </h1>

        <div class="article-meta">
            <span>
        <i class="icon-calendar"></i>
        <span>2017.05.26</span>
            </span>

            
                <span class="article-author">
          <i class="icon-user"></i>
          <span>emacsist</span>
                </span>
                

                    
    <span class="article-category">
    <i class="icon-list"></i>
    
      <a class="tag-item" href="/tags/#汇编语言">
        <span class="tag-name">汇编语言</span>
    <span class="tag-size">( 1 )</span>
    </a>
    

        </span>
        

                        

                                

                                        

        </div>
    </header>

    <div class="article-content">
        
                            <h1 id="第一章：基础知识"><a href="#第一章：基础知识" class="headerlink" title="第一章：基础知识"></a>第一章：基础知识</h1><h2 id="汇编语言的组成"><a href="#汇编语言的组成" class="headerlink" title="汇编语言的组成"></a>汇编语言的组成</h2><ol>
<li>汇编指令：机器码助记符，有对应的机器码</li>
<li>伪指令：没有对应的机器码，由编译器执行，计算机并不执行</li>
<li>其他符号：如 +, -, *, / 等，由编译器识别，没有对应的机器码</li>
</ol>
<h2 id="指令和数据"><a href="#指令和数据" class="headerlink" title="指令和数据"></a>指令和数据</h2><p>指令和数据，是应用上的概念。在内存或磁盘上，指令和数据没有任何区别，都是二进制信息。CPU在工作的时候，把有的信息看作指令，有的信息看作数据，为同样的信息赋予了不同的意义。</p>
<h2 id="存储单元"><a href="#存储单元" class="headerlink" title="存储单元"></a>存储单元</h2><p>每个存储单元从0开始顺序编号，这些编号可以看作是存储单元在存储器中的地址。</p>
<p>一个存储单元可以存储一个 Byte(8 bit)</p>
<h2 id="CPU-对存储器的读写"><a href="#CPU-对存储器的读写" class="headerlink" title="CPU 对存储器的读写"></a>CPU 对存储器的读写</h2><p>必须要进行下面3类信息的交互：</p>
<ul>
<li>存储单元的地址（地址信息）=&gt; 地址总线</li>
<li>器件的选择，读或写的命令（控制信息） =&gt; 控制总线</li>
<li>读或写的数据（数据信息）=&gt; 数据总线</li>
</ul>
<h2 id="数据的读写"><a href="#数据的读写" class="headerlink" title="数据的读写"></a>数据的读写</h2><ul>
<li>读： CPU -&gt; 地址总线：3号地址 -&gt; 控制总线信息：读 -&gt; 内存则将3号地址上的数据通过数据总线返回给CPU</li>
<li>写： CPu -&gt; 地址总线：3号地址 -&gt; 控制总线信息：写 -&gt; CPU通过数据总线发送要写的数据给内存的3号单元</li>
</ul>
<h2 id="命令计算机读写"><a href="#命令计算机读写" class="headerlink" title="命令计算机读写"></a>命令计算机读写</h2><p>即机器码就是驱动CPU来进行读写的，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">MOV AX, [3]</div></pre></td></tr></table></figure>
<p>表示传送3号单元的内容到AX</p>
<h2 id="地址总线"><a href="#地址总线" class="headerlink" title="地址总线"></a>地址总线</h2><p>CPU是通过地址总线来指定存储单元的，可见地址总线上能传送多少个不同的信息，CPU就可以对多少个存储单元进行寻址。（即 CPU 的寻址单位是：一个存储单元，即一个字节）</p>
<p>一个CPU有N根地址线，则可以说这个CPU的地址总线的宽度为N。这样的CPU最多可以寻找2^N次方个内存单元（即 2^N 个字节，注意，不是位）</p>
<h2 id="数据总线"><a href="#数据总线" class="headerlink" title="数据总线"></a>数据总线</h2><p>数据总线的宽度，决定了CPU与外界的数据传送速度。</p>
<h2 id="控制总线"><a href="#控制总线" class="headerlink" title="控制总线"></a>控制总线</h2><p>控制总线是一些不同控制线的集合。有多少根控制总线，就意味着CPU提供了外部器件的多少种控制。所以，控制总线的宽度，决定了CPU对外部器件的控制能力。</p>
<h2 id="内存地址空间"><a href="#内存地址空间" class="headerlink" title="内存地址空间"></a>内存地址空间</h2><p>各类存储器，在物理上是独立的器件，但在以下两点上相同：</p>
<ul>
<li>都和CPU的总线相连</li>
<li>CPU对它们进行读或写的时候，都通过控制线发出内存读写命令。也就是说，CPU在操控它们的时候，<em>把它们都当作内存对待</em> ，把它们总的看作一个由若干存储单元组成的逻辑存储器，这个逻辑存储器就是我们所说的 <em>内存地址空间</em> </li>
</ul>
<p>在汇编中，我们面对的是 <em>内存地址空间</em> 。CPU对这段内存地址空间中读写数据，实际上就是在相应的物理存储器中读写数据。</p>
<p>即，对于CPU来说，系统中所有存储器中的存储单元，都处于一个统一的逻辑存储器中，它的容量受CPU寻址能力的限制。这个逻辑存储器即是我们所说的 <em>内存地址空间</em> </p>
<h3 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h3><p>内存地址空间的大小，受CPU地址总线宽度的限制。</p>
<h3 id="内存地址空间分配"><a href="#内存地址空间分配" class="headerlink" title="内存地址空间分配"></a>内存地址空间分配</h3><p>基于一个计算机硬件系统编程时，必须知道这个系统中的内存地址空间分配情况。因为当我们想在某类存储器中读写数据的时候，必须知道它的第一个单元的地址和最后一个单元的地址，才能保证读写操作是在预期的存储器中进行。</p>
<p>不同的计算机系统的内存地址空间的分配情况是不同的。</p>
<h1 id="第二章：寄存器"><a href="#第二章：寄存器" class="headerlink" title="第二章：寄存器"></a>第二章：寄存器</h1><h2 id="8086-CPU寄存器"><a href="#8086-CPU寄存器" class="headerlink" title="8086 CPU寄存器"></a>8086 CPU寄存器</h2><p>共14个（16位）</p>
<p>这四个是通用寄存器（存放一般性的数据），为了兼容性，可以分开使用两个独立的8位寄存器（H后缀表示高8位，L后缀表示低8位）</p>
<ul>
<li>AX（AH, AL）</li>
<li>BX（BH，BL）</li>
<li>CX（CH，CL）</li>
<li><p>DX（DH，DL）</p>
</li>
<li><p>SI</p>
</li>
<li><p>DI</p>
</li>
<li><p>SP</p>
</li>
<li>BP</li>
<li><p>IP</p>
</li>
<li><p>CS</p>
</li>
<li>SS</li>
<li>DS</li>
<li><p>ES</p>
</li>
<li><p>PSW</p>
</li>
</ul>
<h2 id="字在寄存器中的存储"><a href="#字在寄存器中的存储" class="headerlink" title="字在寄存器中的存储"></a>字在寄存器中的存储</h2><p>出于兼容性的考虑，8086CPU一次性处理以下两种尺寸的数据：</p>
<ul>
<li>字节：byte, 即8 bit ，可以存在8位寄存器中</li>
<li>字：word，即2个byte，这两个字节分别称为这个字的高位字节和低位字节</li>
</ul>
<h2 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h2><p>所有的内存单元构成的存储空间是一个一维的线性空间，每一个内存单元在这个空间中都有唯一的地址，我们将这个唯一的地址称为 <em>物理地址</em> 。</p>
<p>CPU通过地址总线送入存储器的，必须是一个内存单元的 <em>物理地址</em> 。</p>
<p>在CPU向地址总线上发出物理地址之前，必须要在内部先形成这个物理地址。不同的CPU可以有不同的形成物理地址的方式。</p>
<h2 id="16位的CPU"><a href="#16位的CPU" class="headerlink" title="16位的CPU"></a>16位的CPU</h2><p>描述了CPU的结构特性：</p>
<ul>
<li>运算器一次最多可以处理16位的数据</li>
<li>寄存器的最大宽度为16位</li>
<li>寄存器和运算器之间的通路为16位</li>
</ul>
<h2 id="8086-CPU给出物理地址的方法"><a href="#8086-CPU给出物理地址的方法" class="headerlink" title="8086 CPU给出物理地址的方法"></a>8086 CPU给出物理地址的方法</h2><p>8086 CPU有20位地址总线，达1MB寻址能力。但 8086CPU又是16位结构的，如果单纯地发出地址的话，那它只能送出16位的地址，表现出的寻址能力只有64KB。</p>
<p>所以，8086CPU 采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址。</p>
<p>过程：</p>
<ol>
<li>CPU中相关的部件提供两个16位的地址，一个称为 <em>段地址</em> ，另一个称为 <em>偏移地址</em></li>
<li>段地址和偏移地址通过内部总线送入一个称为地址加法器的部件</li>
<li>地址加法器将两个16位地址合成为一个20位的物理地址</li>
<li>地址加法器通过内部总线将20位物理地址送入输入输出控制电路</li>
<li>输入输出控制电路将20位物理地址送上地址总线</li>
<li>20位物理地址被地址总线传送到存储器</li>
</ol>
<p>地址加法器采用： <em>物理地址=段地址 </em> 16 + 偏移地址* (即段地址左移4位) 的方法来合成物理地址。</p>
<h2 id="段地址-16-偏移地址-物理地址-的本质含义"><a href="#段地址-16-偏移地址-物理地址-的本质含义" class="headerlink" title="段地址 * 16 + 偏移地址 = 物理地址 的本质含义"></a>段地址 * 16 + 偏移地址 = 物理地址 的本质含义</h2><p>即：CPU在访问内存时，用一个基础地址（段地址 <em> 16）和一个相对于基础地址的偏移地址相加，给出内存单元的 </em>物理地址* 。即：CPU在访问内存时</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">基础地址 + 偏移地址 = 物理地址</div></pre></td></tr></table></figure>
<p>为什么需要 <em>段地址 </em> 16* 呢？这是因为需要进一位，然后在此基础上再加上偏移地址，这才是正确的物理地址。（这是 8086 CPU 对地址计算的约定）</p>
<h2 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h2><p>8086 CPU有四个段寄存器： CS, DS, SS, ES </p>
<p>段地址在 8086 CPU中由段寄存器存放</p>
<p>CS 和 IP 是8086 CPU中两个最关键的寄存器，它们指示了CPU当前要读取指令的地址。</p>
<p>CS ：为代码段寄存器<br>IP ：为指令指针寄存器</p>
<p>在 8086 PC机中，任意时刻，假设 CS 中的内容为M， IP中的内容为N，8086CPU将从内存 M*16 + N 单元开始读取一条指令并执行。<br>即任意时刻，CPU将 CS:IP 指向的内容当作指令执行</p>
<p>即8086 CPU的工作过程简要如下：</p>
<ol>
<li>从 CS:IP 指向的内存单元读取指令，读取的指令进入指令缓冲器</li>
<li>IP=IP+所读取指令的长度，从而指向下一条指令</li>
<li>执行指令。转至步骤1，重复这个过程</li>
</ol>
<p>在8086CPU加电启动或复位位， CS和IP被设置为 CS=FFFFH， IP=0000H ，即在8086PC机刚启动时，CPU从内存FFFF0H单元中读取指令执行，FFFF0H单元中的指令是8086PC机开机后执行的第一条指令。</p>
<h2 id="修改CS，IP的指令"><a href="#修改CS，IP的指令" class="headerlink" title="修改CS，IP的指令"></a>修改CS，IP的指令</h2><p>程序员能够用指令读写的部件只有寄存器，可以通过改变寄存器中的内容实现对CPU的控制。CPU从何处执行指令，是由CS，IP中的内容决定的，程序员可以通过改变CS，IP中的内容来控制CPU执行目标指令。</p>
<p>能够改变 CS，IP 的内容的指令被统称为 <em>转移指令</em> ，比如 JMP 指令。</p>
<p>同时改变CS和IP：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jmp 段地址:偏移地址</div></pre></td></tr></table></figure>
<p>只改变IP：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jmp 某一合法寄存器</div></pre></td></tr></table></figure>
<p>对于CPU来说，它只认为 CS:IP 指向的内存单元中的内容为指令。</p>
<h2 id="Windows下的-Debug-工具"><a href="#Windows下的-Debug-工具" class="headerlink" title="Windows下的 Debug 工具"></a>Windows下的 Debug 工具</h2><ul>
<li>R: 查看、改变CPU寄存器的内容. <em>r 寄存器</em> 回车，然后输入值，再回车即可修改 <em>寄存器</em> 的值</li>
<li>D: 查看内存中的内容. <em>d 段地址:偏移地址</em>  来查看内存内容。或 <em>d 段地址:偏移地址 结尾偏移地址</em> 或 <em>d 段寄存器:偏移地址</em></li>
<li>E: 改写内存中的内容. <em>e 起始地址 数据1 数据2 数据3 …</em> </li>
<li>U: 将内存中的机器翻译为汇编指令。 <em>u 段地址:偏移地址 结尾偏移地址</em> </li>
<li>T: 执行一条机器指令。直接 t 即可，它会执行 CS:IP 指向的指令。</li>
<li>A: 以汇编指令的格式在内存中写入一条机器指令。 <em>a 段地址:偏移地址</em> 后回车，就可以开始以汇编指令的形式，直接向内存写入数据。</li>
</ul>
<p>注意，要想让CPU执行我们的指令，向内存写好汇编指令后，要将 CS和IP 的值指向相应的内存地址。</p>
<h1 id="第三章：寄存器（内存访问）"><a href="#第三章：寄存器（内存访问）" class="headerlink" title="第三章：寄存器（内存访问）"></a>第三章：寄存器（内存访问）</h1><h2 id="内存中字的存储"><a href="#内存中字的存储" class="headerlink" title="内存中字的存储"></a>内存中字的存储</h2><p>CPU中，用16位寄存器来存储一个字。高8位放在高位字节，低8位放在低位字节。在内存中存储时，由于内存单元是字节单元（一个单元存放一个字节），则一个字要用两个地址连续的内存单元来存放，这个字的低字节放在低地址单元中，高位字节放在高位地址单元中。</p>
<h2 id="DS和-address"><a href="#DS和-address" class="headerlink" title="DS和[address]"></a>DS和[address]</h2><p>8086CPU中，内存地址=段地址+偏移地址 组成。 DS 寄存器通常用来存放要访问数据的段地址。[…] 表示一个内存单元、表示内存单元的偏移地址。</p>
<p>8086CPU中，自动取 DS 中的数据为内存单元的段地址。</p>
<p>MOV 指令中的 <em>[]</em> 说明操作对象是一个内存单元。<em>[]</em> 中的0，说明这个内存单元的偏移地址是0，它的段地址默认放在 DS 中。</p>
<h2 id="内存的读写"><a href="#内存的读写" class="headerlink" title="内存的读写"></a>内存的读写</h2><h3 id="读"><a href="#读" class="headerlink" title="读"></a>读</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">MOV 寄存器, [内存单元地址]</div></pre></td></tr></table></figure>
<h3 id="写"><a href="#写" class="headerlink" title="写"></a>写</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">MOV [内存单元地址]，寄存器</div></pre></td></tr></table></figure>
<h2 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h2><p>将一段内存当作数据段，是我们在编程时的一种安排，可以在具体操作的时候，用 DS 存放数据段的段地址，再根据需要，用相关指令访问数据段中的具体单元。</p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>LIFO（Last In First Out ，后进先出）</p>
<h2 id="CPU提供的栈机制"><a href="#CPU提供的栈机制" class="headerlink" title="CPU提供的栈机制"></a>CPU提供的栈机制</h2><p>8086CPU中提供了相关的指令来以栈的方式访问内存空间。</p>
<ul>
<li>PUSH（入栈）</li>
<li>POP（出栈）</li>
</ul>
<p>它们都是以 <em>字</em> 为单位进行的。</p>
<h3 id="栈顶"><a href="#栈顶" class="headerlink" title="栈顶"></a>栈顶</h3><p>8086CPU中，有两个寄存器，段寄存器 SS 和 寄存器 SP，栈顶的段地址放在 SS 中，偏移地址放在 SP 中。</p>
<p>任意时刻， SS:SP 指向栈顶元素。 PUSH 和 POP 指令执行时，CPU从 SS 和 SP 中得到栈顶的地址。</p>
<p>8086CPU中，入栈时， <em>栈顶从高地址向低地址方向增长</em> .</p>
<h3 id="PUSH"><a href="#PUSH" class="headerlink" title="PUSH"></a>PUSH</h3><p>PUSH AX 步骤：</p>
<ol>
<li>SP=SP-2 ，SS:SP 指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶</li>
<li>将AX中的内容送入 SS:SP 指向的内存单元。SS:SSP 此时指向新栈顶</li>
</ol>
<h3 id="空栈"><a href="#空栈" class="headerlink" title="空栈"></a>空栈</h3><p>以 10000H~1000FH 这段空间看作栈， 此时 SS=1000H，则SP=？</p>
<blockquote>
<p>换个角度看，任意时刻， SS:SP 指向栈顶元素，当栈为空的时候，栈中没有元素，也就不存在栈顶元素，所以 SS:SP 只能指向栈的最底部单元下面的单元，该单元的偏移地址为栈最底部的字单元的偏移地址+2，栈最底部字单元的地址为 1000:000E ，所以栈空时， SP=0010H</p>
</blockquote>
<h3 id="POP"><a href="#POP" class="headerlink" title="POP"></a>POP</h3><p>pop ax 过程</p>
<ol>
<li>将 SS:SP 指向的内存单元处的数据送入 AX</li>
<li>SP=SP+2， SS:SP 指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶</li>
</ol>
<p>注意，POP 之后，只是将 SP 偏移了而已，原数据仍然会在内存中的，但它已经不在栈中了。当再次 PUSH 后，将会写入新的数据。</p>
<h3 id="栈顶超界的问题"><a href="#栈顶超界的问题" class="headerlink" title="栈顶超界的问题"></a>栈顶超界的问题</h3><p>8086CPU中，并不会保证我们对栈的操作不会超界。这也就是说，8086CPU，只知道栈顶在何处（由 SS:SP 指示），而不知道我们安排的栈空间有多大。这点好像CPU只知道当前要执行的指令在何处（由 CS:IP 指示），而不知道要执行的指令有多少。</p>
<p>我们在编程的时候要自己操心栈顶超界的问题，要根据可能用到的最大栈空间，来安排栈的大小，防止入栈的数据太多而导致超界；执行出栈的操作时也要注意，以防栈空的时候继续出栈而导致的超界。</p>
<h3 id="POP-和-PUSH-指令"><a href="#POP-和-PUSH-指令" class="headerlink" title="POP 和 PUSH 指令"></a>POP 和 PUSH 指令</h3><p>它们与 MOV 指令不同， CPU执行 MOV 指令只需要一步。而 PUSH，POP 指令却需要两步。</p>
<p>PUSH：先改变 SP，后向 SS:SP 处传送<br>POP：先读取 SS:SP 处的数据，后改变 SP</p>
<h3 id="栈段"><a href="#栈段" class="headerlink" title="栈段"></a>栈段</h3><p>将一段内存当作栈段，仅仅是我们在编程时的一种安排，CPU并不会由于这种安排，就在执行 PUSH 、POP 等栈操作指令时自动地将我们定义的栈段当作栈空间来访问。它只是简单地访问 SS:SP 指向的地址当作栈段。</p>
<p>这些完全是我们自己安排的：</p>
<p>我们可以用一个段存放数据，将它定义为 “数据段”；（CS:IP）<br>我们可以用一个段存放代码，将它定义为 “代码段”；（DS:[])<br>我们可以用一个段当作栈，将它定义为 “栈段”；(SS:SP)</p>
<p>我们可以这样子安排，但要让CPU按照我们的安排来访问这些段，就要：</p>
<p>对于数据段，将它的段地址放在 DS 中<br>对于代码段，将它的段地址放在 CS 中<br>对于栈段，将它的段地址放在 SS 中，将栈顶单元的偏移地址放在 SP</p>
<blockquote>
<p>注意： Debug  中的 T 命令在执行修改寄存器 SS 的指令时，下一条指令也紧接着被执行。</p>
</blockquote>
<h1 id="第四章：第一个程序"><a href="#第四章：第一个程序" class="headerlink" title="第四章：第一个程序"></a>第四章：第一个程序</h1><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>默认的源码后缀为 <em>.asm</em> ，非这个后缀的，则要写全文件名，包括后缀。</p>
<p>假设源文件为： <em>c:\hello.asm</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">masm c:\hello;</div></pre></td></tr></table></figure>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">link hello;</div></pre></td></tr></table></figure>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">debug hello.exe</div></pre></td></tr></table></figure>
<p>注意，要 <em>hello.exe</em> 是要全名的，不能省略 <em>.exe</em></p>
<h2 id="整个过程"><a href="#整个过程" class="headerlink" title="整个过程"></a>整个过程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">编程 -&gt; 1.asm -&gt; 编译（masm) -&gt; 1.obj -&gt; 链接(link) -&gt; 1.exe -&gt; 加载（<span class="built_in">command</span>) -&gt; 内存中的程序 -&gt; 运行(CPU)</div></pre></td></tr></table></figure>
<h3 id="DOS-的加载过程"><a href="#DOS-的加载过程" class="headerlink" title="DOS 的加载过程"></a>DOS 的加载过程</h3><ol>
<li>找到一段起始地址为： SA:0000（即起始地址的偏移地址为0）的容量足够的空闲内存区</li>
<li>在这段内存区的前 256 个字节中，创建一个称为程序段前缀（PSP）的数据区， DOS 要利用 PSP 来和被加载程序进行通信</li>
<li>从这段内存区的 256 字节处开始（在PSP后面），将程序装入，程序的地址被设置为 SA + 10H:0 （即 PSP的内容范围就是: SA:0 ~ SA+10H:0</li>
<li>将该内存的段地址存入 DS 中，初始化其他相关寄存器后，设置 CS:IP 指向程序的入口</li>
</ol>
<p>PSP的内容为：</p>
<p><img src="/img/assembly-00.png" alt="img"></p>
<ol>
<li>程序加载后， DS 中存放着程序所在内存区的段地址，这个内存区的偏移地址为0，则程序所在的内存区的地址为 DS:0 </li>
<li>这个内存区的前 256 个字节中存放的是 <em>PSP</em> ， DOS 用来和程序进行通信。从 256 字节处向后的空间存放的是程序</li>
</ol>
<p>所以， 从 DS 中可以得到 PSP 的段地址 SA， PSP 的偏移地址为 0，则物理地址为 SA * 16 + 0<br>因为 PSP 占 256 （100H）字节，所以程序的物理地址为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SA * 16 + 0 + 256 = SA * 16 + 16 * 16 + 0 = (SA+16) * 16 + 0</div><div class="line"></div><div class="line">用段地址和偏移地址表示为：</div><div class="line">SA + 10H:0</div></pre></td></tr></table></figure>
<h2 id="单任务执行过程"><a href="#单任务执行过程" class="headerlink" title="单任务执行过程"></a>单任务执行过程</h2><ol>
<li>由其他程序（debug, command或其他程序），将可执行文件中的程序加载入内存</li>
<li>设置 CS:IP 指向程序的第一条要执行的指令（即程序的入口），从而使程序得以运行</li>
<li>程序运行结束后，返回到加载者</li>
</ol>
<h1 id="第五章：-BX-和-loop指令"><a href="#第五章：-BX-和-loop指令" class="headerlink" title="第五章：[BX] 和 loop指令"></a>第五章：[BX] 和 loop指令</h1><p>要完整地描述一个内存单元，需要两种信息</p>
<ol>
<li>内存单元的地址：DS 为段地址， [N] N 为偏移地址</li>
<li>内存单元的长度（类型）：可以由具体指令中其他操作对象（比如说寄存器）指出</li>
</ol>
<p>[BX] 同样也表示一个内存单元，它的偏移地址在 BX 中</p>
<h2 id="loop-指令"><a href="#loop-指令" class="headerlink" title="loop 指令"></a>loop 指令</h2><p>下面2步是自动CPU处理的</p>
<ol>
<li>CX = CX - 1</li>
<li>CX 不为0，则转至标号处执行； 如果为0，则向下执行</li>
</ol>
<blockquote>
<p>汇编源程序中，数据不能以字母开头</p>
</blockquote>
<h2 id="debug-中的-G-命令"><a href="#debug-中的-G-命令" class="headerlink" title="debug 中的 G 命令"></a>debug 中的 G 命令</h2><p>它可以让 CPU 一直执行到指定的地址中为止:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">G 0012</div></pre></td></tr></table></figure>
<p>即将程序执行到 IP 地址为 0012H 的地方</p>
<h2 id="debug-中的-P-命令"><a href="#debug-中的-P-命令" class="headerlink" title="debug 中的 P 命令"></a>debug 中的 P 命令</h2><p>它会自动重复执行循环中的指令，直到 CX = 0 为止 。即在 CS:IP 指向 <em>loop xxx</em> 时，输入 <em>p</em> 命令即可。</p>
<p>当然，也可以用 G 命令来间接实现这个目的</p>
<h2 id="debug-和汇编器-masm-对指令的不同处理"><a href="#debug-和汇编器-masm-对指令的不同处理" class="headerlink" title="debug 和汇编器 masm 对指令的不同处理"></a>debug 和汇编器 masm 对指令的不同处理</h2><p>debug 中: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mov ax, [0]</div><div class="line"></div><div class="line">它表示将 ds:0 处的数据送入 ax 中</div></pre></td></tr></table></figure>
<p>masm 源代码中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mov ax,[0]</div><div class="line"></div><div class="line">编译后，生成的是 </div><div class="line">mov ax, 0</div></pre></td></tr></table></figure>
<p>所以，在 masm 这样子的要显式出给段地址:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mov ax, ds:[0]</div><div class="line"></div><div class="line">或</div><div class="line"></div><div class="line">mov ax, [bx]</div><div class="line">这样子它就会默认是 DS:[bx] 了</div></pre></td></tr></table></figure>
<h2 id="一段安全的空间"><a href="#一段安全的空间" class="headerlink" title="一段安全的空间"></a>一段安全的空间</h2><p>不能确定一段内存空间中是否存放着重要的数据或代码的时候，不能随意向其中写入内容。</p>
<p>不要忘记，我们是在操作系统的环境中工作，操作系统管理所有的资源，也包括内存。如果我们需要向内存空间写入数据的话，要使用操作系统给我们分配的空间，而不应直接用地址任意指定内存单元，向里面写入。</p>
<p>在CPU保护模式下的操作系统(Windows 2000, Unix)中，硬件已经被这些操作系统利用CPU保护模式所提供的功能全面而严格地管理了。</p>
<h1 id="第六章：包含多个段的程序"><a href="#第六章：包含多个段的程序" class="headerlink" title="第六章：包含多个段的程序"></a>第六章：包含多个段的程序</h1><p>程序取得所需空间的方法有两种</p>
<ol>
<li>在加载程序的时候为程序分配</li>
<li>程序在执行的过程中向系统申请</li>
</ol>
<h2 id="程序第一条指令"><a href="#程序第一条指令" class="headerlink" title="程序第一条指令"></a>程序第一条指令</h2><p>这是由可执行文件中描述信息指明的。</p>
<p>可执行文件由描述信息和程序组成</p>
<ul>
<li>程序来自于源程序中的汇编指令和定义的数据</li>
<li>描述信息则主要是编译、连接程序对源程序中相关伪指令进行处理所得到的信息</li>
</ul>
<h2 id="只用一个段来写代码"><a href="#只用一个段来写代码" class="headerlink" title="只用一个段来写代码"></a>只用一个段来写代码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">assume cs:code</div><div class="line"></div><div class="line">code segment</div><div class="line">   ...</div><div class="line">   数据</div><div class="line">   ...</div><div class="line"></div><div class="line">start:</div><div class="line">   ...</div><div class="line">   代码</div><div class="line">   ...</div><div class="line">code ends</div><div class="line"></div><div class="line">end start</div></pre></td></tr></table></figure>
<h2 id="多段"><a href="#多段" class="headerlink" title="多段"></a>多段</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">assume cs:code, ds:data, ss:stack</div><div class="line"></div><div class="line">data segment</div><div class="line">    dw 0123h, 0456h, 0789h, 0abch, 0defh, 0fedh, 0cbah, 0987h</div><div class="line">data ends</div><div class="line"></div><div class="line">stack segment</div><div class="line">    dw 0,0,0,0,0,0,0,0,0,0</div><div class="line">stack ends</div><div class="line"></div><div class="line"></div><div class="line">code segment</div><div class="line"></div><div class="line">start:</div><div class="line">    mov ax, stack</div><div class="line">    mov ss, ax</div><div class="line">    mov sp, 20h</div><div class="line">    mov ax, data</div><div class="line">    mov ds, ax</div><div class="line">    mov bx, 0</div><div class="line">    mov cx, 8</div><div class="line"></div><div class="line">s:  </div><div class="line">    push [bx]</div><div class="line">    add bx, 2</div><div class="line">    loop s</div><div class="line"></div><div class="line">    mov bx,0</div><div class="line">    mov cx,8</div><div class="line"></div><div class="line">s0:</div><div class="line">    pop [bx]</div><div class="line">    add bx,2</div><div class="line">    loop s0</div><div class="line"></div><div class="line"></div><div class="line">    mov ax, 4c00</div><div class="line">    int 21h</div><div class="line"></div><div class="line">code ends</div><div class="line"></div><div class="line">end start</div></pre></td></tr></table></figure>
<h1 id="第七章：更灵活的定位内存地址的方法"><a href="#第七章：更灵活的定位内存地址的方法" class="headerlink" title="第七章：更灵活的定位内存地址的方法"></a>第七章：更灵活的定位内存地址的方法</h1><h2 id="and-和-or-指令"><a href="#and-和-or-指令" class="headerlink" title="and 和 or 指令"></a>and 和 or 指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mov al,01100011B</div><div class="line">add al,00111011B</div><div class="line"></div><div class="line">or al,00111011B</div></pre></td></tr></table></figure>
<h2 id="bx-idata"><a href="#bx-idata" class="headerlink" title="[bx+idata]"></a>[bx+idata]</h2><p>[bx+idata] 表示一个内存单元，它的偏移地址为 [bx] + idata 。也可以写成如下格式:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mov ax, [200+bx]</div><div class="line">或</div><div class="line">mov ax, 200[bx]</div><div class="line">或</div><div class="line">mov ax, [bx].200</div></pre></td></tr></table></figure>
<h2 id="SI-和-DI"><a href="#SI-和-DI" class="headerlink" title="SI 和 DI"></a>SI 和 DI</h2><p>它们和 BX 功能相近。但 SI 和 DI 不能够分成两个8位寄存器来使用。</p>
<h2 id="bx-si-和-bx-di"><a href="#bx-si-和-bx-di" class="headerlink" title="[bx+si] 和 [bx+di]"></a>[bx+si] 和 [bx+di]</h2><p>指明内存单元:</p>
<ul>
<li>[bx(si或di)]</li>
<li>[bx(si或di) + idata]</li>
</ul>
<p>也可以:</p>
<ul>
<li>[bx+si]</li>
<li>[bx+di]</li>
</ul>
<p>表示一个内存单元，它的偏移地址为 [bx] + [si] 或 [bx] + [di]</p>
<h2 id="bx-si-idata-和-bx-di-idata"><a href="#bx-si-idata-和-bx-di-idata" class="headerlink" title="[bx+si+idata] 和 [bx+di+idata]"></a>[bx+si+idata] 和 [bx+di+idata]</h2><p>表示一个内存单元，它的偏移地址为： [bx] + [si] + idata</p>
<h2 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h2><ul>
<li>[idata] : 用一个常量来表示地址，可用于直接定位一个内存单元</li>
<li>[bx] : 用一个变量来表示内存地址，可用于间接定位一个内存单元</li>
<li>[bx+idata] : 用一个变量和常量表示地址，可在一个起始地址的基础上，用变量间接定位一个内存单元</li>
<li>[bx+si或di] : 用两个变量表示地址</li>
<li>[bx+si或di+idata] : 用两个变量和一个常量表示地址</li>
</ul>
<h1 id="第八章：数据处理的两个基本问题"><a href="#第八章：数据处理的两个基本问题" class="headerlink" title="第八章：数据处理的两个基本问题"></a>第八章：数据处理的两个基本问题</h1><ol>
<li>处理的数据在什么地方</li>
<li>要处理的数据有多长</li>
</ol>
<h2 id="bx-si-di-和-bp"><a href="#bx-si-di-和-bp" class="headerlink" title="bx, si, di 和 bp"></a>bx, si, di 和 bp</h2><ol>
<li>只有这4个寄存器可以在 [..] 中进行内存单元的寻址</li>
<li>在 [..] 中，这4个寄存器可以单个出现，或只能以4种组合出现：bx和si， bx和di， bp和si, bp和di</li>
<li>在 [..] 中使用寄存器 bp, 而指令中没有显性地给出段地址，段地址默认就在 SS 中</li>
</ol>
<h2 id="机器指令处理的数据在什么地方"><a href="#机器指令处理的数据在什么地方" class="headerlink" title="机器指令处理的数据在什么地方"></a>机器指令处理的数据在什么地方</h2><p>在机器指令这一层，并不关心数据的值是多少，而关心 <em>指令执行前一刻</em> ，它将要处理的数据所在的位置。可以在3个地方：</p>
<ol>
<li>CPU 内部</li>
<li>内存</li>
<li>端口</li>
</ol>
<h2 id="数据位置的表达"><a href="#数据位置的表达" class="headerlink" title="数据位置的表达"></a>数据位置的表达</h2><h3 id="立即数"><a href="#立即数" class="headerlink" title="立即数"></a>立即数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mov ax, 1</div></pre></td></tr></table></figure>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mov ax, bx</div></pre></td></tr></table></figure>
<h3 id="段地址（SA）和偏移地址（EA）"><a href="#段地址（SA）和偏移地址（EA）" class="headerlink" title="段地址（SA）和偏移地址（EA）"></a>段地址（SA）和偏移地址（EA）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mov ax, [0]</div></pre></td></tr></table></figure>
<h2 id="寻址方式-1"><a href="#寻址方式-1" class="headerlink" title="寻址方式"></a>寻址方式</h2><h3 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[idata]</div></pre></td></tr></table></figure>
<h3 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[bx]</div><div class="line">[si]</div><div class="line">[di]</div><div class="line">[bp]</div></pre></td></tr></table></figure>
<h3 id="寄存器相对寻址"><a href="#寄存器相对寻址" class="headerlink" title="寄存器相对寻址"></a>寄存器相对寻址</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[bx+idata]</div><div class="line">[si+idata]</div><div class="line">[di+idata]</div><div class="line">[bp+idata]</div></pre></td></tr></table></figure>
<h3 id="基址变址寻址"><a href="#基址变址寻址" class="headerlink" title="基址变址寻址"></a>基址变址寻址</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[bx+si]</div><div class="line">[bx+di]</div><div class="line">[bp+si]</div><div class="line">[bp+di]</div></pre></td></tr></table></figure>
<h3 id="相对基址变址寻址"><a href="#相对基址变址寻址" class="headerlink" title="相对基址变址寻址"></a>相对基址变址寻址</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[bx+si+idata]</div><div class="line">[bx+di+idata]</div><div class="line">[bx+si+idata]</div><div class="line">[bp+di+idata]</div></pre></td></tr></table></figure>
<h2 id="要处理数据的长度"><a href="#要处理数据的长度" class="headerlink" title="要处理数据的长度"></a>要处理数据的长度</h2><p>8086CPU 可以处理两种尺寸的数据： byte 和 word</p>
<ol>
<li>通过寄存器名指明处理的数据的尺寸</li>
<li>没有寄存器名存在的情况下， 用 <em>X ptr</em> 指明内存单元的长度，X 可以为 word 或 byte</li>
<li>其他方法。有些指令默认访问的是字单元，还是字节单元。比如 push 就只能进行字单元操作</li>
</ol>
<h2 id="div-指令"><a href="#div-指令" class="headerlink" title="div 指令"></a>div 指令</h2><ol>
<li>除数：8位或16位，在一个寄存器或内存单元中</li>
<li>被除数：默认放在AX或DX和AX中。如果除数为8位，被除数则为16位，默认在AX中存放；如果除数为16位，被除数则为32位，在DX和AX中存放，DX存放高16位，AX存放低16位</li>
<li>结果：如果除数为8位，则AL存储除法操作的商，AH存储除法操作的余数；如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数</li>
</ol>
<h2 id="dup"><a href="#dup" class="headerlink" title="dup"></a>dup</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">db 重复次数 dup (重复的字节型数据)</div><div class="line">dw 重复次数 dup (重复的字型数据)</div><div class="line">dd 重复次数 dup (重复的双字型数据)</div></pre></td></tr></table></figure>
<h1 id="第九章：转移指令的原理"><a href="#第九章：转移指令的原理" class="headerlink" title="第九章：转移指令的原理"></a>第九章：转移指令的原理</h1><p>可以修改 IP 或同时修改 CS 和 IP 的指令统称为 <em>转移指令</em> </p>
<ul>
<li><p>只修改IP，称为段内转移，如: jmp ax</p>
<ul>
<li>短转移: IP 修改的范围为: -128 ~ 127</li>
<li>近转移：IP 修改的范围为: -32768 ~ 32767</li>
</ul>
</li>
<li><p>同时修改 CS 和 IP 称为段间转移，如: jmp 1000:0</p>
</li>
</ul>
<h2 id="转移指令分类"><a href="#转移指令分类" class="headerlink" title="转移指令分类"></a>转移指令分类</h2><ul>
<li>无条件转移指令，如 jmp</li>
<li>条件转移指令</li>
<li>循环指令， 如 loop</li>
<li>过程</li>
<li>中断</li>
</ul>
<h2 id="offset"><a href="#offset" class="headerlink" title="offset"></a>offset</h2><p>它是由编译器处理的符号，功能是： 取得标号的偏移地址</p>
<h2 id="jmp-指令"><a href="#jmp-指令" class="headerlink" title="jmp 指令"></a>jmp 指令</h2><p>要出给两种信息：</p>
<ul>
<li>转移的目的地址</li>
<li>转移的距离（段间转移、段内短转移、段内近转移）</li>
</ul>
<h2 id="依据位移进行转移的-jmp-指令"><a href="#依据位移进行转移的-jmp-指令" class="headerlink" title="依据位移进行转移的 jmp 指令"></a>依据位移进行转移的 jmp 指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jmp short 标号</div></pre></td></tr></table></figure>
<p>它对IP的修改范围为 -128 ~ 127 ，即向前最多 128 个字节， 向后最多 127 个字节。</p>
<p>注意：CPU 执行 JMP 指令的时候，并不需要转移的目的地址。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jmp short 标号</div></pre></td></tr></table></figure>
<p>并不包含转移的目的地址，而包含的是 <em>转移的位移</em> 。这个位移，是编译器根据汇编指令中的 <em>标号</em> 计算出来的。</p>
<h2 id="转移的目的地址在指令中的-jmp-指令"><a href="#转移的目的地址在指令中的-jmp-指令" class="headerlink" title="转移的目的地址在指令中的 jmp 指令"></a>转移的目的地址在指令中的 jmp 指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jmp far ptr 标号</div></pre></td></tr></table></figure>
<p>它是段间转移，又称为远转移。它会同时修改 CS 和 IP</p>
<h2 id="转移地址在寄存器中的-jmp-指令"><a href="#转移地址在寄存器中的-jmp-指令" class="headerlink" title="转移地址在寄存器中的 jmp 指令"></a>转移地址在寄存器中的 jmp 指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jmp 16位寄存器</div></pre></td></tr></table></figure>
<p>功能： IP = 16位寄存器的值</p>
<h2 id="转移地址在内存中的-jmp-指令"><a href="#转移地址在内存中的-jmp-指令" class="headerlink" title="转移地址在内存中的 jmp 指令"></a>转移地址在内存中的 jmp 指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">jmp word ptr 内存单元地址（段内转移）</div><div class="line"></div><div class="line">jmp dword prt 内存单元地址（段间转移）</div></pre></td></tr></table></figure>
<h2 id="jcxz-指令"><a href="#jcxz-指令" class="headerlink" title="jcxz 指令"></a>jcxz 指令</h2><p>它是条件转移指令。<br>所有的条件转移指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为： -128 ~ 127</p>
<p>如果 cx = 0 ，则转移到标号处执行，否则程序向下执行。</p>
<h2 id="loop-指令-1"><a href="#loop-指令-1" class="headerlink" title="loop 指令"></a>loop 指令</h2><p>它是循环指令。<br>所有的循环指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为：-128 ~ 127</p>
<p>CX = CX-1，然后 CX != 0 ，则转移到标号处执行。</p>
<h1 id="第十章：CALL-和-RET-指令"><a href="#第十章：CALL-和-RET-指令" class="headerlink" title="第十章：CALL 和 RET 指令"></a>第十章：CALL 和 RET 指令</h1><h2 id="ret-和-retf"><a href="#ret-和-retf" class="headerlink" title="ret 和 retf"></a>ret 和 retf</h2><p>ret =&gt; 用栈中的数据，修改IP的内容，从而实现近转移</p>
<ol>
<li>IP = SS * 16 + SP</li>
<li>SP = SP + 2</li>
</ol>
<p>相当于:</p>
<p>pop IP</p>
<p>retf =&gt; 用栈中的数据，修改CS和IP，从而实现远转移</p>
<ol>
<li>IP = SS * 16 + SP</li>
<li>SP = SP + 2</li>
<li>CS = SS * 16 + SP</li>
<li>SP = SP + 2</li>
</ol>
<p>相当于:</p>
<p>pop IP<br>pop CS</p>
<h2 id="call-指令"><a href="#call-指令" class="headerlink" title="call 指令"></a>call 指令</h2><ol>
<li>将当前 IP 或 CS 和 IP 压入栈</li>
<li>转移</li>
</ol>
<p>它不能实现短转移，除此之餐，它和 JMP 指令的原理相同。</p>
<h2 id="依据位移进行转移的-call-指令"><a href="#依据位移进行转移的-call-指令" class="headerlink" title="依据位移进行转移的 call 指令"></a>依据位移进行转移的 call 指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">call 标号（将当前IP压入栈后，转移到标号处执行指令）</div></pre></td></tr></table></figure>
<ol>
<li>SP = SP + 2; SS *16 + SP = IP</li>
<li>IP = IP + 16位位移</li>
</ol>
<h2 id="转移的目的地址在指令中的-call-指令"><a href="#转移的目的地址在指令中的-call-指令" class="headerlink" title="转移的目的地址在指令中的 call 指令"></a>转移的目的地址在指令中的 call 指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">call far prt 标号</div></pre></td></tr></table></figure>
<p>它是段间转移。</p>
<ol>
<li>SP = SP - 2; SS <em> 16 + SP = CS; SP = SP - 2; SS </em> 16 + SP = IP</li>
<li>CS = 标号所在段的段地址； IP = 标号所在段中的偏移地址</li>
</ol>
<p>相当于:</p>
<p>push CS<br>push IP<br>jmp far prt 标号</p>
<h2 id="转移地址在寄存器中的-call-指令"><a href="#转移地址在寄存器中的-call-指令" class="headerlink" title="转移地址在寄存器中的 call 指令"></a>转移地址在寄存器中的 call 指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">call 16位寄存器</div></pre></td></tr></table></figure>
<ol>
<li>SP = SP - 2 </li>
<li>SS * 16 + SP = IP</li>
<li>IP = 16位寄存器的值</li>
</ol>
<h2 id="转移地址在内存中的-call-指令"><a href="#转移地址在内存中的-call-指令" class="headerlink" title="转移地址在内存中的 call 指令"></a>转移地址在内存中的 call 指令</h2><p>两种格式：</p>
<ol>
<li>call word prt 内存单元地址</li>
</ol>
<p>push ip<br>jmp word ptr 内存单元地址</p>
<ol>
<li>call dword prt 内存单元地址</li>
</ol>
<p>push cs<br>push ip<br>jmp dword prt 内存单元地址</p>
<h2 id="mul-指令"><a href="#mul-指令" class="headerlink" title="mul 指令"></a>mul 指令</h2><ul>
<li>两个相乘数：要么都是8位，要么都是16位。如果是8位，则一个默认在 AL 中，另一个在 8 位寄存器或内存字节单元中。要么是 16 位，一个默认在 AX 中，另一个在 16 位或内存字节单元中。</li>
<li>结果：8位的话，结果默认在 AX 中； 16 位，则默认高位在 DX 中，低位在 AX 中</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mul 寄存器</div><div class="line">mul 内存单元</div></pre></td></tr></table></figure>
<h1 id="第十一章：标志寄存器"><a href="#第十一章：标志寄存器" class="headerlink" title="第十一章：标志寄存器"></a>第十一章：标志寄存器</h1><p>特殊的寄存器作用：</p>
<ul>
<li>存储相关指令的某些执行结果</li>
<li>为CPU执行相关指令提供行为依据</li>
<li>控制CPU的相关工作方式</li>
</ul>
<p>其他寄存器是用来存放数据的，都是整个寄存具有一个含义。而标志寄存器，是按拉起作用的，也就是说，它的每一位都有专门的含义，记录特定的信息。</p>
<h2 id="0：CF"><a href="#0：CF" class="headerlink" title="0：CF"></a>0：CF</h2><p>进位标志位。一般情况下，在进行 <em>无符号</em> 运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值</p>
<h2 id="2：PF"><a href="#2：PF" class="headerlink" title="2：PF"></a>2：PF</h2><p>奇偶标志位。它记录相关指令执行后，其结果的所有 bit 位中 1 的个数是否为偶数。如果1的个数为偶数，则 PF = 1， 如果为奇数，则 PF = 0</p>
<h2 id="4：AF"><a href="#4：AF" class="headerlink" title="4：AF"></a>4：AF</h2><h2 id="6：ZF"><a href="#6：ZF" class="headerlink" title="6：ZF"></a>6：ZF</h2><p>零标志位。它记录相关指令执行后，结果是否为0.如果为0，ZF=1，否则 ZF=0 </p>
<h2 id="7：SF"><a href="#7：SF" class="headerlink" title="7：SF"></a>7：SF</h2><p>符号标志位。它记录相关指令执行后，其结果是否为负。如果为负，SF = 1， 如果非负， SF = 0</p>
<h2 id="8：TF"><a href="#8：TF" class="headerlink" title="8：TF"></a>8：TF</h2><h2 id="9：IF"><a href="#9：IF" class="headerlink" title="9：IF"></a>9：IF</h2><p>IF = 0，在进入中断处理程序后，禁止其他的可屏蔽中断。<br>IF = 0，表示中断处理程序需要处理可屏蔽中断。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sti ：设置 IF = 1</div><div class="line">cli : 设置 IF = 0</div></pre></td></tr></table></figure>
<h2 id="10：DF"><a href="#10：DF" class="headerlink" title="10：DF"></a>10：DF</h2><p>方向标志位。在串处理指令中，控制每次操作后 si, di 的增减。</p>
<p>DF = 0 ：每次操作后， si, di 递增<br>DF = 1 : 每次操作后， si，di 递减</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cld 指令：将标志寄存器的 DF 位置0</div><div class="line">std 指令：将标志寄存器的 DF 位置1</div></pre></td></tr></table></figure>
<h2 id="11：OF"><a href="#11：OF" class="headerlink" title="11：OF"></a>11：OF</h2><p>溢出标志位。一般情况下，OF 记录了 <em>有符号</em> 运算的结果是否发生了溢出。如果溢出了， OF = 1 ，如果没有， OF = 0 </p>
<p>注意， OF 是对有符号的。CF 是对无符号的</p>
<h2 id="adc-指令"><a href="#adc-指令" class="headerlink" title="adc 指令"></a>adc 指令</h2><p>adc 是带进位加法指令。它利用了 CF 位上记录的进位值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">adc 操作对象1，操作对象2</div><div class="line"></div><div class="line">结果为</div><div class="line">操作对象1 = 操作对象1 + 操作对象2 + CF</div></pre></td></tr></table></figure>
<p>利用它，可以对任意大的数据进行加法运算。</p>
<h2 id="sbb-指令"><a href="#sbb-指令" class="headerlink" title="sbb 指令"></a>sbb 指令</h2><p>它是带借位减法指令，它利用了 CF 位上记录的借位值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sbb 操作对象1，操作对象2</div><div class="line"></div><div class="line">功能</div><div class="line">操作对象1 = 操作对象1 - 操作对象2 - CF</div></pre></td></tr></table></figure>
<p>利用它，可以对任意大的数据进行减法运算。</p>
<h2 id="cmp-指令"><a href="#cmp-指令" class="headerlink" title="cmp 指令"></a>cmp 指令</h2><p>它相当于减法，只是不保存结果。将对标志寄存器产生影响。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cmp 操作对象1， 操作对象2</div><div class="line"></div><div class="line">功能</div><div class="line">操作对象1 - 操作对象2 ，但并不保存结果，仅仅是对标志寄存器进行设置</div></pre></td></tr></table></figure>
<h2 id="检测比较结果的条件转移指令"><a href="#检测比较结果的条件转移指令" class="headerlink" title="检测比较结果的条件转移指令"></a>检测比较结果的条件转移指令</h2><p>下面是常用的根据 <em>无符号</em> 数的比较结果进行转移的条件转移指令</p>
<h3 id="je"><a href="#je" class="headerlink" title="je"></a>je</h3><p>equal</p>
<p>等于则转移。检测的是 ZF = 1</p>
<h3 id="jne"><a href="#jne" class="headerlink" title="jne"></a>jne</h3><p>not equal</p>
<p>不等于则转移，检测的是 ZF = 0</p>
<h3 id="jb"><a href="#jb" class="headerlink" title="jb"></a>jb</h3><p>below</p>
<p>低于则转移，检测的是 CF = 1</p>
<h3 id="jnb"><a href="#jnb" class="headerlink" title="jnb"></a>jnb</h3><p>not below</p>
<p>不低于则转移，检测的是 CF = 0</p>
<h3 id="ja"><a href="#ja" class="headerlink" title="ja"></a>ja</h3><p>above</p>
<p>高于则转移。 CF = 0 且 ZF = 0</p>
<h3 id="jna"><a href="#jna" class="headerlink" title="jna"></a>jna</h3><p>not above</p>
<p>不高于则转移。 CF = 1 或 ZF = 1</p>
<h2 id="pushf-和-popf"><a href="#pushf-和-popf" class="headerlink" title="pushf 和 popf"></a>pushf 和 popf</h2><p>pushf ：将标志寄存器的值压栈<br>popf : 从栈中弹出数据，送入标志寄存器</p>
<h1 id="第十二章：内中断"><a href="#第十二章：内中断" class="headerlink" title="第十二章：内中断"></a>第十二章：内中断</h1><p>中断信息可以来自 CPU 的内部和外部。</p>
<h2 id="中断的产生"><a href="#中断的产生" class="headerlink" title="中断的产生"></a>中断的产生</h2><ul>
<li>除法错误：中断类型码为0</li>
<li>单步执行：中断类型码为1</li>
<li>执行 into 指令：中断类型码为4</li>
<li>执行 int 指令： int N，N为字节型立即数，即提供给CPU的中断类型码</li>
</ul>
<p>8086CPU用称为中断类型码的数据来标识中断信息的来源。</p>
<p>中断类型码为一个字节型数据，可以表示 256 种中断信息的来源。</p>
<h2 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h2><p>CPU用8位的中断类型码通过中断向量表，找到相应的中断处理程序的入口地址。</p>
<p>所谓中断向量，就是中断处理程序的入口地址。展开来讲，中断向量表，就是中断处理程序的入口地址的列表。</p>
<p>中断向量表在内存中存放。对于 8086CPU，中断向量表指定放在内存地址 0 处。从内存 0000:0000 到 0000:03FF 的1024个单元中存放着中断向量表。</p>
<p>一个表项存放着一个中断向量，也就是一个中断处理程序的入口地址，对于 8086CPU， 这个入口地址包括段地址和偏移地址，所以，一个表项占两个字，高地址存放段地址，低地址存放偏移地址。</p>
<h2 id="中断过程"><a href="#中断过程" class="headerlink" title="中断过程"></a>中断过程</h2><p>找到中断入口地址的最终目的是用它设置 CS 和 IP ，使CPU执行中断处理程序。</p>
<p>用中断类型码找到中断向量，并用它设置 CS 和 IP 这个工作是由 CPU 硬件自动完成的。CPU 硬件完成这个工作的过程，称为 中断过程</p>
<p>整个过程如下：</p>
<ol>
<li>取得中断类型码 N</li>
<li>pushf</li>
<li>TF = 0, IF = 0</li>
<li>push CS</li>
<li>push IP</li>
<li>IP = N <em> 4, CS = N </em> 4 + 2</li>
</ol>
<h2 id="中断处理程序和-iret-指令"><a href="#中断处理程序和-iret-指令" class="headerlink" title="中断处理程序和 iret 指令"></a>中断处理程序和 iret 指令</h2><p>中断处理程序的常规步骤：</p>
<ol>
<li>保存用到的寄存器</li>
<li>处理中断</li>
<li>恢复用到的寄存器</li>
<li>用 iret 指令返回</li>
</ol>
<p>iret 指令用汇编语法表述为：</p>
<p>POP IP<br>POP CS<br>popf</p>
<h2 id="响应中断的特殊情况"><a href="#响应中断的特殊情况" class="headerlink" title="响应中断的特殊情况"></a>响应中断的特殊情况</h2><p>举例：CPU在执行完 SS 指令后，不响应中断。</p>
<p>这给连续设置 SS 和 SP 指向正确的栈顶提供了一个时机。</p>
<h1 id="第十三章：int-指令"><a href="#第十三章：int-指令" class="headerlink" title="第十三章：int 指令"></a>第十三章：int 指令</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int n</div></pre></td></tr></table></figure>
<p>它的功能是：引发中断号为 N 的中断过程</p>
<h2 id="BIOS-和-DOS-中断例程的安装过程"><a href="#BIOS-和-DOS-中断例程的安装过程" class="headerlink" title="BIOS 和 DOS 中断例程的安装过程"></a>BIOS 和 DOS 中断例程的安装过程</h2><ol>
<li>开机后， CPU一加电，初始化 CS = 0FFFFH， IP=0 ，自动从 FFFF:0 单元开始执行程序。FFFF:0 有一条转跳指令，CPU执行后，转去执行BIOS中的硬件系统检测和初始化程序。</li>
<li>初始化程序将建立 BIOS 所支持的中断向量，即将 BIOS 提供的中断例程的入口地址登记在中断向量表中。注意，对于BIOS所提供的中断例程，只需要将入口地址登记在中断向量表中即可，因为它们是固化到 ROM 中的程序，一直在系统内存中存在。</li>
<li>硬件系统检测和初始化完成后，调用 int 19H 进行操作系统的引导，从此将计算机交由操作系统控制</li>
<li>DOS 启动后，除完成其他工作以外，还将它提供的中断例程装入内存，并建立相应的中断向量</li>
</ol>
<p>BIOS 和 DOS 提供的中断例程，都是用 AH 来传递 <em>内部子程序的编号</em> 。</p>
<h1 id="第十四章：端口"><a href="#第十四章：端口" class="headerlink" title="第十四章：端口"></a>第十四章：端口</h1><p>CPU可以直接读写以下3个地方的数据</p>
<ol>
<li>CPU内部的寄存器</li>
<li>内存单元</li>
<li>端口</li>
</ol>
<h2 id="端口的读写"><a href="#端口的读写" class="headerlink" title="端口的读写"></a>端口的读写</h2><p>它和内存地址一样，通过地址总线来传送。在PC中，CPU最多可定位64KB个不同的端口。则端口地址的范围为 0 ~ 65535</p>
<p>它只有两个指令：</p>
<p>in ：读<br>out : 写</p>
<p>在 in 和 out 指令中，只能使用 ax 或 al 来存放从端口中读入的数据或要发送到端口中的数据。8位时，使用 AL， 16位时， 使用 AX</p>
<h2 id="SHL-和-SHR-指令"><a href="#SHL-和-SHR-指令" class="headerlink" title="SHL 和 SHR 指令"></a>SHL 和 SHR 指令</h2><p>SHL 的功能：</p>
<ol>
<li>将一个寄存器或内存单元中的数据向左移位</li>
<li>将最后移出的一位写入 CF 中</li>
<li>最低位用 0 补充</li>
</ol>
<p>SHR 与 SHR 的操作刚好相反</p>
<h1 id="第十五章：外中断"><a href="#第十五章：外中断" class="headerlink" title="第十五章：外中断"></a>第十五章：外中断</h1><p>PC系统的接口卡和主板上，装有各种接口芯片。这些外设接口芯片的内部有若干寄存器，CPU将这些寄存器当作端口来访问。</p>
<h2 id="外中断源"><a href="#外中断源" class="headerlink" title="外中断源"></a>外中断源</h2><h3 id="可屏蔽中断"><a href="#可屏蔽中断" class="headerlink" title="可屏蔽中断"></a>可屏蔽中断</h3><p>如果 IF = 1，则CPU执行完当前指令后响应中断，引发中断过程；<br>如果 IF = 0，则不响应可屏蔽中断</p>
<h3 id="不可屏蔽中断"><a href="#不可屏蔽中断" class="headerlink" title="不可屏蔽中断"></a>不可屏蔽中断</h3><p>是CPU必须响应的外中断。对于 8086CPU，不可屏蔽中断的中断类型码固定为 2 ，所以，中断过程中，不需要取中断类型码。</p>
<p>几乎所有由外设引发的外中为，都是 <em>可屏蔽中断</em> 。</p>
<h2 id="PC-机键盘的处理过程"><a href="#PC-机键盘的处理过程" class="headerlink" title="PC 机键盘的处理过程"></a>PC 机键盘的处理过程</h2><p>按下一个键时产生的扫描码称为 <em>通码</em><br>松开一个键时产生的扫描码称为 <em>断码</em></p>
<p>扫描码长度为：一个字节。通码的第7位为0，断码的第7位为1 。即：</p>
<p>断码 = 通码 + 80H</p>
<h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><h2 id="显存的物理地址"><a href="#显存的物理地址" class="headerlink" title="显存的物理地址"></a>显存的物理地址</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">B8000~BFFFF</div></pre></td></tr></table></figure>
<h2 id="ASCII-与-显卡文本模式显示"><a href="#ASCII-与-显卡文本模式显示" class="headerlink" title="ASCII 与 显卡文本模式显示"></a>ASCII 与 显卡文本模式显示</h2><p>ASCII 是7位代码，只用了一个字节中的低7比特，最高位通常置0 。这意味着，ASCII只包含 128 个字符的编码。</p>
<p><code>屏幕上的每个字符，对应着显存中的两个连续字节。</code> 前一个字节是字符的ASCII代码，后一个字节是显示属性，包括字符颜色（前景色）和底色（背景色）。</p>
<p>显示属性分为两部分，低4位定义的是前景色，高4位是背景色。<br>RGBK（背景色），其中K是闪烁位，0为不闪烁，1为闪烁。<br>RGBL（前景色），其中L是亮度位，0为正常亮度，1为高亮。</p>
<h2 id="MOV"><a href="#MOV" class="headerlink" title="MOV"></a>MOV</h2><p>目的操作数不能为立即数，而且目的操作数和源操作数不允许同时为内存单元。</p>
<h2 id="汇编地址"><a href="#汇编地址" class="headerlink" title="汇编地址"></a>汇编地址</h2><p>它是在源程序编译期间，编译器为每条指令确定的汇编位置，指示该指令相对于程序或段起始处的距离，以字节计算。当编译后的程序装入物理内存后，它又是该指令在内存段内的偏移地址。</p>
<h2 id="jmp-near-xxx"><a href="#jmp-near-xxx" class="headerlink" title="jmp near xxx"></a>jmp near xxx</h2><p>jmp near 的操作数并非目标位置的偏移地址，而是目标位置 <em>相对于当前指令处的偏移量（以字节为单位）</em></p>
<p>编译器对它的处理：<br>用标号（目标位置）处的汇编地址减去当前指令的汇编地址，再减去当前指令的长度（3)，就得到了 jmp near xxx 指令的实际操作数。</p>
<h2 id="movsb-或-movsw"><a href="#movsb-或-movsw" class="headerlink" title="movsb 或 movsw"></a>movsb 或 movsw</h2><p>源数据：DS:SI<br>目的地：ES:DI</p>
<p>CX: 次数</p>
<p>DF标志位：<br>cld =&gt; 清0，表示传送的是正向（从内存低地址到高地址）<br>std =&gt; 置1，表示传送的是反向（从内存高地址到低地址）</p>
<p>MOVSB 或 MOVSW 通常与 rep (表示 repeat) 结合使用。</p>
<h2 id="偏移地址"><a href="#偏移地址" class="headerlink" title="偏移地址"></a>偏移地址</h2><p>如果要用寄存器来提供偏移地址，只能使用：</p>
<p>bx, si, di, bp 不能使用其他寄存器。</p>
<h2 id="cbw-或-cwd"><a href="#cbw-或-cwd" class="headerlink" title="cbw 或 cwd"></a>cbw 或 cwd</h2><p>cbw =&gt; (convert byte to word)，将 AL 中的有符号数扩展到整个AX。如果AL为 10001101，执行完这指令后，AX为 1111111110001101<br>cbd =&gt; (convert word to double word)，将AX中的有符号数扩展到 DX:AX 。</p>
<h2 id="call-指令-1"><a href="#call-指令-1" class="headerlink" title="call 指令"></a>call 指令</h2><h3 id="相对近调用"><a href="#相对近调用" class="headerlink" title="相对近调用"></a>相对近调用</h3><p>这个是通过符号或立即数（立即数也要减去当前指令的汇编地址）给出的。</p>
<p>计算过程：</p>
<p>用目标过程的汇编地址送去当前 call 指令的汇编地址，于减去当前 call 以字节为单位的长度（3），保留16位的结果。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">call near xxx</div></pre></td></tr></table></figure>
<p>near 不是必须的，如果不提供任何关键字，则默认就是 near </p>
<h3 id="绝对近调用"><a href="#绝对近调用" class="headerlink" title="绝对近调用"></a>绝对近调用</h3><p>这个是通过寄存器或内存单元给出目标地址的。</p>
<h3 id="绝对远调用"><a href="#绝对远调用" class="headerlink" title="绝对远调用"></a>绝对远调用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">call xxxx:yyyy</div></pre></td></tr></table></figure>
<h3 id="间接绝对远调用"><a href="#间接绝对远调用" class="headerlink" title="间接绝对远调用"></a>间接绝对远调用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">call far [xxx]</div></pre></td></tr></table></figure>
<p>它会使用 xxx 处的2个字（注意是字，第一个字是偏移地址，第二个字是段地址）来分别代替IP和CS的内容。</p>
<h2 id="ret-和-retf-1"><a href="#ret-和-retf-1" class="headerlink" title="ret 和 retf"></a>ret 和 retf</h2><p>ret 和 retf 经常用做 call 和  call far 的配对指令。</p>
<p>ret 是近返回：它只做一件事，就是从栈中弹出一个字到指令指针寄存器IP中</p>
<p>retf 是远返回：处理器分别从栈中弹出两个字到指令指针寄存器IP和代码段寄存器CS中</p>
<p>call 和 ret , retf 不会影响任何的标志寄存器</p>
<h2 id="jmp"><a href="#jmp" class="headerlink" title="jmp"></a>jmp</h2><h3 id="相对短转移"><a href="#相对短转移" class="headerlink" title="相对短转移"></a>相对短转移</h3><p>jmp short 标号或数值</p>
<p>用目标地址减去当前指令的汇编地址，再减去当前指令的长度（2），保留一个 <em>字节</em> 的结果（结果是有符号数）</p>
<h3 id="16位相对近转移"><a href="#16位相对近转移" class="headerlink" title="16位相对近转移"></a>16位相对近转移</h3><p>jmp near 标号或数值</p>
<p>用目标地址减去当前指令的汇编地址，再减去当前指令的长度（3），保留一个字（16位）的结果。（结果是有符号数）</p>
<h3 id="16位间接绝对近转移"><a href="#16位间接绝对近转移" class="headerlink" title="16位间接绝对近转移"></a>16位间接绝对近转移</h3><p>jmp near bx</p>
<p>它也是近转移，即只是段内转移。但目标地址是通过寄存器或内存地址（该地址里的内存内容）给出的</p>
<h3 id="16位直接绝对远转移"><a href="#16位直接绝对远转移" class="headerlink" title="16位直接绝对远转移"></a>16位直接绝对远转移</h3><p>jmp xxxx:yyyy</p>
<h3 id="16位间接绝对远转移"><a href="#16位间接绝对远转移" class="headerlink" title="16位间接绝对远转移"></a>16位间接绝对远转移</h3><p>标号 dw yyyy, xxxx<br>jmp far [标号]</p>
<p>注意，第一个字是偏移地址，第二个才是段地址</p>
<p>即相当于转移到 jmp far xxxx:yyyy</p>
<h2 id="iret"><a href="#iret" class="headerlink" title="iret"></a>iret</h2><p>这个是中断返回指令，它会导致处理器依次从栈中弹出（恢复）IP、CS 和 Flags 的原始内容。</p>
<h2 id="CMOS-RAM"><a href="#CMOS-RAM" class="headerlink" title="CMOS RAM"></a>CMOS RAM</h2><p>前14个字节分别为：</p>
<p>0x0：秒<br>0x1：闹钟秒<br>0x2：分<br>0x3：闹钟分<br>0x4：时<br>0x5：闹钟时<br>0x6：星期<br>0x7：日<br>0x8：月<br>0x9：年<br>0xa: 寄存器A<br>0xb: 寄存器B<br>0xc: 寄存器C<br>0xd: 寄存器D</p>
<p>访问需要通过两个端口：</p>
<p>0x70或0x74 =&gt; 它是索引端口，用于指定CMOS RAM的内存单元<br>0x71或0x75 =&gt; 它是数据端口，用来读写相应的内存单元</p>
<p>比如下面代码就是读取星期几：</p>
<p>MOV  al,0x06<br>OUT  0x70, al<br>IN    al, 0x71</p>
<p>我现在是星期四（因为我系统设置了每周第一天为星期天），所以下面的数值为05（实际是我们一般人理解的星期四，只是不同的起始计数不同）</p>
<p><img src="/img/asm-get-week.jpg" alt="img"></p>
<p>执行完后，可以看到al值为 05 （它是以星期天为开始计数的，即星期一～星期天为， 01~07）</p>

                                
    </div>
</article>

   
  <div class="text-center donation">
    <div class="inner-donation">
      <span class="btn-donation">支持一下</span>
      <div class="donation-body">
        <div class="tip text-center">扫一扫，支持 emacsist</div>
        <ul class="theme.donation.items.length">
        
          <li class="item">
            <img src="/img/wxpay.jpeg" alt="">
          </li>
        
          <li class="item">
            <img src="/img/alipay.jpeg" alt="">
          </li>
        
        </ul>
      </div>
    </div>
  </div>


   



</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tags/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/books/"
              rel="noopener noreferrer"
              target="_self"
              >
              阅读
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    




    

    
	
  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
